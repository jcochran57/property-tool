<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cochran Claims - 3D Multi-Room Property Tool</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Professional property measurement and estimation tool for insurance claims">
    <meta name="theme-color" content="#1e3c72">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Property Tool">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .top-bar {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 15px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            z-index: 100;
        }

        .branding {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .company-name {
            font-size: 20px;
            font-weight: 700;
        }

        .view-controls {
            display: flex;
            gap: 10px;
        }

        .view-btn {
            padding: 10px 20px;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-weight: 600;
        }

        .view-btn.active {
            background: white;
            color: #1e3c72;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .left-panel {
            width: 350px;
            background: white;
            border-right: 2px solid #ddd;
            display: flex;
            flex-direction: column;
        }

        .room-manager {
            background: #f9f9f9;
            border-bottom: 2px solid #ddd;
            padding: 15px;
        }

        .room-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .add-room-btn {
            padding: 8px 16px;
            background: #1e3c72;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .room-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .room-item {
            padding: 12px;
            margin-bottom: 6px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .room-item.active {
            background: #1e3c72;
            color: white;
        }

        .room-delete {
            width: 24px;
            height: 24px;
            background: rgba(255,0,0,0.1);
            color: #f44336;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 13px;
            font-weight: 600;
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
        }

        .wall-entry {
            padding: 12px;
            background: #f9f9f9;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .feature-btn {
            padding: 12px;
            min-height: 44px; /* iOS minimum touch target */
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            font-weight: 600;
            -webkit-tap-highlight-color: rgba(30, 60, 114, 0.3);
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            pointer-events: auto;
            position: relative;
            z-index: 10;
        }
        
        .feature-btn:active {
            transform: scale(0.98);
            background: #f0f0f0;
        }

        .feature-btn.active {
            background: #1e3c72;
            color: white;
        }

        .canvas-area {
            flex: 1;
            position: relative;
            background: #f0f0f0;
        }

        #canvas2D, #canvas3D {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #canvas2D {
            background: white;
            z-index: 1;
        }

        #canvas3D {
            display: none;
            z-index: 2;
        }

        .view-3d #canvas2D {
            display: none;
            pointer-events: none;
            z-index: 0;
        }

        .view-3d #canvas3D {
            display: block;
            pointer-events: auto;
            z-index: 2;
        }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .view-3d .zoom-controls {
            display: none;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            margin: 4px 0;
            background: #1e3c72;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: block;
        }

        .stats-overlay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            min-width: 220px;
            z-index: 50; /* Above canvas but below modals */
            display: block; /* Ensure it's visible */
        }

        .stats-overlay h4 {
            margin: 0 0 12px 0;
            color: #1e3c72;
            font-size: 16px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 14px;
        }

        .stat-value {
            font-weight: 700;
            color: #1e3c72;
        }

        .bottom-toolbar {
            background: white;
            padding: 15px 25px;
            display: flex;
            justify-content: space-between;
            border-top: 2px solid #ddd;
        }

        .btn {
            padding: 12px 20px;
            background: #1e3c72;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            margin-right: 10px;
            /* iPad/Touch optimizations */
            -webkit-tap-highlight-color: rgba(30, 60, 114, 0.3);
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .btn:active {
            transform: scale(0.98);
            background: #152a52;
        }

        .controls-3d {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 12px;
            display: none;
        }

        .view-3d .controls-3d {
            display: block;
        }

        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            display: none;
            z-index: 10000;
        }

        .toast.active {
            display: block;
        }

        .placement-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            z-index: 10000;
            display: none;
            min-width: 400px;
        }

        .placement-dialog.active {
            display: block;
        }

        .dialog-title {
            font-size: 20px;
            font-weight: 700;
            color: #1e3c72;
            margin-bottom: 20px;
        }

        .dialog-field {
            margin-bottom: 15px;
        }

        .dialog-field label {
            display: block;
            font-weight: 600;
            margin-bottom: 6px;
            font-size: 14px;
        }

        .dialog-field input,
        .dialog-field select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
        }

        .dialog-buttons {
            display: flex;
            gap: 10px;
            margin-top: 25px;
        }

        .dialog-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
        }

        .dialog-btn-primary {
            background: #1e3c72;
            color: white;
        }

        .dialog-btn-secondary {
            background: #e0e0e0;
            color: #333;
        }

        .wall-highlight {
            cursor: pointer;
        }

        .wall-highlight:hover {
            opacity: 0.7;
        }

        .instruction-banner {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 60, 114, 0.95);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-weight: 600;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            font-size: 16px;
            animation: pulse 2s ease-in-out infinite;
        }

        .instruction-banner.active {
            display: block;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .mode-indicator {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            z-index: 999;
        }

        .mode-indicator.delete-mode {
            background: rgba(76, 175, 80, 0.9);
        }

        .mode-indicator.wall-mode {
            background: rgba(255, 152, 0, 0.9);
        }

        .clear-mode-btn {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: #f44336;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            z-index: 999;
        }

        /* ===== iPad Responsive Design ===== */
        @media screen and (max-width: 1366px) {
            /* Optimize for iPad Landscape & smaller screens */
            
            .left-panel {
                width: 280px; /* Narrower sidebar */
            }
            
            .company-name {
                font-size: 16px;
            }
            
            .top-bar {
                padding: 10px 15px;
            }
            
            .view-btn {
                padding: 8px 15px;
                font-size: 14px;
            }
        }
        
        @media screen and (max-width: 1024px) {
            /* iPad Portrait mode */
            
            .left-panel {
                width: 250px; /* Even narrower */
            }
            
            .panel-content {
                padding: 10px;
                font-size: 13px;
            }
            
            .form-group {
                margin-bottom: 10px;
            }
            
            .form-group label {
                font-size: 12px;
                margin-bottom: 3px;
            }
            
            .form-group input,
            .form-group select {
                font-size: 13px;
                padding: 6px;
            }
            
            .feature-btn {
                padding: 10px 8px;
                font-size: 13px;
            }
            
            h3 {
                font-size: 16px;
                margin-bottom: 10px;
            }
            
            h4 {
                font-size: 13px;
                margin: 15px 0 8px 0;
            }
            
            .btn {
                padding: 10px 15px;
                font-size: 14px;
            }
            
            /* Stats panel - smaller on iPad */
            .stats-overlay {
                bottom: 10px;
                right: 10px;
                padding: 12px;
                min-width: 180px;
            }
            
            .stats-overlay h4 {
                font-size: 14px;
                margin-bottom: 8px;
            }
            
            .stat-row {
                font-size: 12px;
                padding: 4px 0;
            }
        }
        
        /* Ensure sidebar scrolls properly */
        .panel-content {
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }
        
        /* Modal Overlay Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        
        .modal {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
        
        .modal h3 {
            margin: 0 0 20px 0;
            color: #1e3c72;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .modal-buttons button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
        
        .modal-content h3 {
            margin: 0 0 20px 0;
            color: #1e3c72;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="top-bar">
            <div class="branding">
                <div class="company-logo">üìê</div>
                <div class="company-name">Cochran Claims - Property Tool</div>
            </div>
            <div class="view-controls">
                <button class="view-btn active" onclick="switch2D()">üìê 2D View</button>
                <button class="view-btn" onclick="switch3D()">üè† 3D View</button>
                <button class="view-btn" onclick="resetCamera()" title="Reset camera to default position">üîÑ Reset Camera</button>
            </div>
        </div>

        <div class="main-content">
            <div class="left-panel">
                <div class="room-manager">
                    <div class="room-header">
                        <h3>üè† Rooms</h3>
                        <div style="display: flex; gap: 5px;">
                            <button class="add-room-btn" onclick="undo()" title="Undo last action (Ctrl+Z)" style="background: #FF9800;">‚Ü∂ Undo</button>
                            <button class="add-room-btn" onclick="addNewRoom()">+ Add Room</button>
                        </div>
                    </div>
                    <div class="room-list" id="roomList"></div>
                    
                    <div style="margin-top: 15px; padding: 10px; background: #f0f0f0; border-radius: 4px;">
                        <h4 style="margin: 0 0 10px 0; font-size: 13px;">üìç 3D Position</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                            <div>
                                <label style="font-size: 11px;">X (left/right)</label>
                                <input type="number" id="roomPosX" value="0" step="5" style="width: 100%; padding: 4px;" onchange="updateRoomPosition()">
                            </div>
                            <div>
                                <label style="font-size: 11px;">Z (forward/back)</label>
                                <input type="number" id="roomPosZ" value="0" step="5" style="width: 100%; padding: 4px;" onchange="updateRoomPosition()">
                            </div>
                        </div>
                        <button onclick="resetRoomPosition()" style="width: 100%; margin-top: 8px; padding: 4px; font-size: 11px;">Reset Position</button>
                    </div>
                </div>

                <div class="panel-content">
                    <h3 style="margin-bottom: 15px;">Current Room Setup</h3>
                    
                    <div class="form-group">
                        <label>Number of Walls</label>
                        <select id="wallCount" onchange="generateWallInputs()">
                            <option value="3">3 Walls</option>
                            <option value="4" selected>4 Walls</option>
                            <option value="5">5 Walls</option>
                            <option value="6">6 Walls</option>
                            <option value="7">7 Walls</option>
                            <option value="8">8 Walls</option>
                            <option value="9">9 Walls</option>
                            <option value="10">10 Walls</option>
                            <option value="11">11 Walls</option>
                            <option value="12">12 Walls</option>
                        </select>
                    </div>

                    <div id="wallInputs"></div>

                    <div class="form-group">
                        <label>Ceiling Height (ft)</label>
                        <input type="number" id="ceilingHeight" value="8.0" step="0.1">
                    </div>

                    <div class="form-group">
                        <label>Wall Thickness (inches)</label>
                        <input type="number" id="wallThickness" value="4" min="4" max="24" step="1">
                    </div>

                    <button class="btn" id="applyMeasurementsBtn" style="width: 100%;">
                        ‚úì Apply Measurements
                    </button>

                    <h4 style="margin: 20px 0 10px 0;">Add Features</h4>
                    <div class="feature-grid">
                        <button class="feature-btn" id="doorBtn" onclick="selectFeature('door', event)">üö™ Door</button>
                        <button class="feature-btn" id="windowBtn" onclick="selectFeature('window', event)">ü™ü Window</button>
                        <button class="feature-btn" id="openingBtn" onclick="selectFeature('missing-wall', event)">üß± Opening</button>
                        <button class="feature-btn" id="waterBtn" onclick="selectFeature('water-damage', event)">üíß Water</button>
                        <button class="feature-btn" id="fireBtn" onclick="selectFeature('fire-damage', event)">üî• Fire</button>
                    </div>
                </div>
            </div>

            <div class="canvas-area" id="canvasArea">
                <canvas id="canvas2D"></canvas>
                <div id="canvas3D"></div>

                <div style="position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.95); padding: 10px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); z-index: 100;">
                    <label style="display: flex; align-items: center; cursor: pointer; font-size: 14px; font-weight: 600;">
                        <input type="checkbox" id="showAllRooms" onchange="toggleShowAllRooms()" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                        <span>üèòÔ∏è Show All Rooms</span>
                    </label>
                    <div id="allRoomsHelp" style="font-size: 11px; color: #666; margin-top: 5px; display: none;">
                        Click and drag rooms to move them
                    </div>
                </div>

                <div class="zoom-controls">
                    <button id="zoomInBtn" class="zoom-btn" onclick="zoomIn()">+</button>
                    <div id="zoomLevel" style="text-align: center; padding: 8px 0;">100%</div>
                    <button id="zoomOutBtn" class="zoom-btn" onclick="zoomOut()">‚àí</button>
                    <button id="resetZoomBtn" class="zoom-btn" onclick="resetZoom()">‚äô</button>
                    <button id="zoomAllBtn" class="zoom-btn" onclick="zoomAll()" title="Zoom to fit room">üîç All</button>
                    <div style="font-size: 10px; text-align: center; margin-top: 8px; color: #666;">
                        üñ±Ô∏è Mouse Wheel = Zoom<br>
                        Shift+Drag = Pan<br>
                        üëÜ Tap buttons for zoom/pan
                    </div>
                </div>

                <div class="controls-3d">
                    <h4>üéÆ 3D Controls</h4>
                    <p style="font-size: 13px; margin-top: 10px;">
                        ‚Ä¢ Drag to rotate<br>
                        ‚Ä¢ Scroll to zoom<br>
                        ‚Ä¢ Shows all rooms
                    </p>
                </div>

                <div class="stats-overlay">
                    <h4>üìä Current Room</h4>
                    <div class="stat-row">
                        <span>Floor Area:</span>
                        <span class="stat-value" id="statArea">0 sq ft</span>
                    </div>
                    <div class="stat-row">
                        <span>Perimeter:</span>
                        <span class="stat-value" id="statPerimeter">0 ft</span>
                    </div>
                    <div class="stat-row">
                        <span>Doors:</span>
                        <span class="stat-value" id="statDoors">0</span>
                    </div>
                    <div class="stat-row">
                        <span>Windows:</span>
                        <span class="stat-value" id="statWindows">0</span>
                    </div>
                </div>

                <div class="instruction-banner" id="instructionBanner">
                    Click on a wall to place the feature
                </div>

                <div class="mode-indicator" id="modeIndicator">
                    üìè EDIT MODE - Click feature to edit/delete
                </div>

                <button class="clear-mode-btn" id="clearModeBtn" onclick="clearAllModes()" style="display: none;">
                    ‚ùå Clear Mode
                </button>
            </div>
        </div>

        <div class="bottom-toolbar">
            <div>
                <button class="btn" onclick="saveProject()">üíæ Save Project</button>
                <button class="btn" onclick="copyProjectData()" title="Backup: Copy project to clipboard">üìã Copy Data</button>
                <div style="position: relative; display: inline-block;">
                    <button class="btn" onclick="toggleExportMenu()" id="exportBtn">üì§ Export ‚ñº</button>
                    <div id="exportMenu" style="display: none; position: absolute; bottom: 100%; left: 0; background: white; border: 2px solid #1e3c72; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); min-width: 220px; z-index: 1000; margin-bottom: 5px;">
                        <div onclick="exportReport()" style="padding: 12px 20px; cursor: pointer; border-bottom: 1px solid #ddd; font-weight: 600; color: #333;" onmouseover="this.style.background='#f0f7ff'" onmouseout="this.style.background='white'">
                            üìÑ Standard Report
                        </div>
                        <div onclick="exportXactimateCSV()" style="padding: 12px 20px; cursor: pointer; border-bottom: 1px solid #ddd; font-weight: 600; color: #333;" onmouseover="this.style.background='#f0f7ff'" onmouseout="this.style.background='white'">
                            üìä Xactimate CSV
                        </div>
                        <div onclick="exportXactimateReport()" style="padding: 12px 20px; cursor: pointer; border-bottom: 1px solid #ddd; font-weight: 600; color: #333;" onmouseover="this.style.background='#f0f7ff'" onmouseout="this.style.background='white'">
                            üìã Xactimate Report
                        </div>
                        <div onclick="exportForExcel()" style="padding: 12px 20px; cursor: pointer; font-weight: 600; color: #2e7d32; background: #e8f5e9;" onmouseover="this.style.background='#c8e6c9'" onmouseout="this.style.background='#e8f5e9'">
                            üìä Excel Estimator
                        </div>
                    </div>
                </div>
                <button class="btn" onclick="loadProject()">üìÇ Load</button>
            </div>
            <div style="display: flex; align-items: center; gap: 20px;">
                <div style="font-weight: 600; color: #1e3c72; font-size: 15px;">
                    üìã <span id="projectNameDisplay">Untitled Project</span>
                </div>
                <div id="coordinates" style="color: #666;">Ready</div>
            </div>
        </div>
    </div>

    
    <!-- Missing Wall Modal -->
    <div class="modal-overlay" id="missingWallModal" style="display:none;">
        <div class="modal">
            <h3 id="missingWallModalTitle">üß± Missing Wall</h3>
            <p style="margin:6px 0 12px;color:#666;font-size:13px;">Room: <span id="missingWallRoomName"></span></p>

            <div class="form-group">
                <label for="missingWallSelect">Wall</label>
                <select id="missingWallSelect"></select>
            </div>

            <div class="form-group">
                <label for="missingWallReference">Measure From</label>
                <select id="missingWallReference">
                    <option value="left">Left Corner</option>
                    <option value="right">Right Corner</option>
                </select>
            </div>

            <div style="display:flex;gap:10px;">
                <div class="form-group" style="flex:1;">
                    <label for="missingWallStart" id="missingWallStartLabel">Start (ft from left corner)</label>
                    <input type="number" id="missingWallStart" step="0.1" min="0" value="0">
                </div>
                <div class="form-group" style="flex:1;">
                    <label for="missingWallEnd" id="missingWallEndLabel">End (ft from left corner)</label>
                    <input type="number" id="missingWallEnd" step="0.1" min="0" value="1">
                </div>
            </div>

            <div style="display:flex;gap:10px;">
                <div class="form-group" style="flex:1;">
                    <label for="missingWallHeight">Height (ft)</label>
                    <input type="number" id="missingWallHeight" step="0.5" min="0.5" max="20" value="3">
                </div>
                <div class="form-group" style="flex:1;">
                    <label for="missingWallFloorDist">Distance from Floor (ft)</label>
                    <input type="number" id="missingWallFloorDist" step="0.5" min="0" max="20" value="0">
                </div>
            </div>

            <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:14px;">
                <button class="btn btn-danger" id="missingWallDeleteBtn" onclick="deleteCurrentMissingWall()" style="display:none;">üóëÔ∏è Delete</button>
                <button class="btn btn-primary" onclick="cancelMissingWall()">Cancel</button>
                <button class="btn btn-success" id="missingWallConfirmBtn" onclick="confirmMissingWall()">‚úÖ Save</button>
            </div>
        </div>
    </div>

<div class="toast" id="toast"></div>
    
    <!-- Custom Edit Name Modal -->
    <div id="editNameModal" onclick="if(event.target === this) cancelEditName()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 400px; width: 90%;">
            <h3 style="margin: 0 0 20px 0; color: #1e3c72; font-size: 20px;">‚úèÔ∏è Edit Room Name</h3>
            <input type="text" id="editNameInput" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 20px; box-sizing: border-box;" placeholder="Enter room name">
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="cancelEditName()" style="padding: 10px 20px; font-size: 14px; background: #ccc; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Cancel</button>
                <button onclick="confirmEditName()" style="padding: 10px 20px; font-size: 14px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Save</button>
            </div>
        </div>
    </div>

    <!-- Custom Add Room Modal -->
    <div id="addRoomModal" onclick="if(event.target === this) cancelAddRoom()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 400px; width: 90%;">
            <h3 style="margin: 0 0 20px 0; color: #1e3c72; font-size: 20px;">üè† Add New Room</h3>
            <input type="text" id="addRoomInput" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 20px; box-sizing: border-box;" placeholder="Enter room name">
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="cancelAddRoom()" style="padding: 10px 20px; font-size: 14px; background: #ccc; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Cancel</button>
                <button onclick="confirmAddRoom()" style="padding: 10px 20px; font-size: 14px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Add Room</button>
            </div>
        </div>
    </div>

    <!-- Custom Position Editor Modal -->
    <div id="positionModal" onclick="if(event.target === this) cancelPosition()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 500px; width: 90%; max-height: 85vh; overflow-y: auto;">
            <h3 style="margin: 0 0 10px 0; color: #1e3c72; font-size: 20px;" id="positionModalTitle">üìè Reposition Door</h3>
            <p style="margin: 0 0 20px 0; color: #666; font-size: 14px;" id="positionModalHelp">Enter the distance from LEFT corner to LEFT EDGE of feature</p>
            
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #e9ecef;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span style="color: #666; font-size: 13px;">Current Wall:</span>
                    <span style="font-weight: 600; color: #1e3c72;" id="positionCurrentWall">Wall 1</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span style="color: #666; font-size: 13px;">Wall Length:</span>
                    <span style="font-weight: 600; color: #1e3c72;" id="positionWallLength">20.0 ft</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span style="color: #666; font-size: 13px;">Feature Width:</span>
                    <span style="font-weight: 600; color: #4A90E2;" id="positionFeatureWidth">3.0 ft</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #666; font-size: 13px;">Current Left Edge:</span>
                    <span style="font-weight: 600; color: #FF6B6B;" id="positionCurrentPos">5.0 ft</span>
                </div>
            </div>
            
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Measure From:</label>
            <select id="positionReferenceCorner" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box;">
                <option value="left">Left Corner</option>
                <option value="right">Right Corner</option>
            </select>
            
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;" id="positionDistanceLabel">Distance to Left Edge (feet):</label>
            <input type="number" id="positionInput" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box;" placeholder="Enter distance in feet" step="0.1" min="0">
            
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Width (inches):</label>
            <input type="number" id="positionWidthInput" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box;" placeholder="Width in inches" step="1" min="12" max="120">

            <div id="positionHeightFields" style="display: none;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;" for="positionHeightInput">Height (inches):</label>
                <input type="number" id="positionHeightInput" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box;" placeholder="Height in inches" step="1" min="12" max="120">

                <div id="positionFloorHeightFields">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Height from Floor (feet):</label>
                    <input type="number" id="positionFloorHeightInput" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box;" placeholder="Distance from floor" step="0.5" min="0" max="10">
                </div>
                
                <div id="positionDoorSwingFields" style="display: none;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Hinge Side:</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <button id="hingeLeftBtn" onclick="setDoorHinge('left')" style="flex: 1; padding: 12px; font-size: 14px; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; background: white; font-weight: 600;">
                            ‚¨ÖÔ∏è Left
                        </button>
                        <button id="hingeRightBtn" onclick="setDoorHinge('right')" style="flex: 1; padding: 12px; font-size: 14px; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; background: white; font-weight: 600;">
                            Right ‚û°Ô∏è
                        </button>
                    </div>
                    
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Opens:</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <button id="swingInBtn" onclick="setDoorSwingDirection('in')" style="flex: 1; padding: 12px; font-size: 14px; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; background: white; font-weight: 600;">
                            ‚¨áÔ∏è Into Room
                        </button>
                        <button id="swingOutBtn" onclick="setDoorSwingDirection('out')" style="flex: 1; padding: 12px; font-size: 14px; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; background: white; font-weight: 600;">
                            ‚¨ÜÔ∏è Out of Room
                        </button>
                    </div>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: space-between;">
                <button onclick="deleteCurrentFeature()" style="padding: 10px 20px; font-size: 14px; background: #f44336; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">üóëÔ∏è Delete</button>
                <div style="display: flex; gap: 10px;">
                    <button onclick="cancelPosition()" style="padding: 10px 20px; font-size: 14px; background: #ccc; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Cancel</button>
                    <button onclick="confirmPosition()" style="padding: 10px 20px; font-size: 14px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Apply Position</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Filename Modal -->
    <div id="filenameModal" onclick="if(event.target === this) cancelFilename()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 500px; width: 90%;">
            <h3 style="margin: 0 0 10px 0; color: #1e3c72; font-size: 20px;" id="filenameModalTitle">üíæ Save Project</h3>
            <p style="margin: 0 0 20px 0; color: #666; font-size: 14px;">Enter a name for your project</p>
            
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Project Name:</label>
            <input type="text" id="filenameInput" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 20px; box-sizing: border-box;" placeholder="e.g., 123 Main Street - Smith Property">
            
            <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 20px; font-size: 13px; color: #666;">
                üí° <strong>Tip:</strong> Use a descriptive name like address or client name for easy identification
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="cancelFilename()" style="padding: 10px 20px; font-size: 14px; background: #ccc; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Cancel</button>
                <button onclick="confirmFilename()" style="padding: 10px 20px; font-size: 14px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;" id="filenameConfirmBtn">Save</button>
            </div>
        </div>
    </div>

    <!-- Cut Wall Modal -->
    <div id="cutWallModal" onclick="if(event.target === this) cancelCutWall()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000;">
        <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 500px; width: 90%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
            <h3 id="cutWallModalTitle" style="margin: 0 0 10px 0; color: #1e3c72; font-size: 20px;">‚úÇÔ∏è Cut Portion of Wall</h3>
            <p style="margin: 0 0 20px 0; color: #666; font-size: 14px;">Delete a section of wall by specifying dimensions (e.g., for a doorway)</p>
            
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #e9ecef;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span style="color: #666; font-size: 13px;">Room:</span>
                    <span style="font-weight: 600; color: #1e3c72;" id="cutWallRoomName">Living Room</span>
                </div>
            </div>
            
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Select Wall:</label>
            <select id="cutWallSelect" style="width: 100%; padding: 10px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px;">
                <option value="">Choose a wall...</option>
            </select>
            
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">Start Distance from Left (feet):</label>
            <input type="number" id="cutWallStart" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box;" placeholder="e.g., 2.0" step="0.1" min="0">
            
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">End Distance from Left (feet):</label>
            <input type="number" id="cutWallEnd" style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box;" placeholder="e.g., 5.0" step="0.1" min="0">
            
            <div style="background: #fff3cd; padding: 12px; border-radius: 6px; margin-bottom: 20px; font-size: 13px; color: #856404; border: 1px solid #ffeaa7;">
                üí° <strong>Example:</strong> To cut 3 feet starting at 2 feet, enter Start: 2.0, End: 5.0
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: space-between; align-items: center;">
                <button onclick="deleteCurrentCutWall()" id="cutWallDeleteBtn" style="padding: 10px 20px; font-size: 14px; background: #f44336; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; display: none;">üóëÔ∏è Delete Cut</button>
                <div style="display:flex; gap:10px; justify-content:flex-end; flex:1;">
                    <button onclick="cancelCutWall()" style="padding: 10px 20px; font-size: 14px; background: #ccc; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Cancel</button>
                    <button onclick="confirmCutWall()" id="cutWallConfirmBtn" style="padding: 10px 20px; font-size: 14px; background: #FF5722; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">‚úÇÔ∏è Cut Wall</button>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept=".json" style="display:none;">

    <div class="placement-dialog" id="placementDialog">
        <div class="dialog-title" id="dialogTitle">Add Door</div>
        
        <div class="dialog-field">
            <label>Width (inches)</label>
            <input type="number" id="featureWidth" value="36" min="12" max="120" step="6">
        </div>

        <div class="dialog-field" id="heightField" style="display: none;">
            <label id="heightFieldLabel">Height from Floor (feet)</label>
            <input type="number" id="featureHeight" value="3.0" min="0" max="10" step="0.5">
        </div>

        <div class="dialog-field" id="windowHeightField" style="display: none;">
            <label>Window Height (inches)</label>
            <input type="number" id="featureWindowHeight" value="36" min="12" max="120" step="6">
        </div>

        <div style="padding: 10px; background: #f0f7ff; border-radius: 6px; margin: 15px 0; font-size: 13px; color: #666;">
            üìç Feature will be placed at your click point on the wall
        </div>

        <div class="dialog-buttons">
            <button class="dialog-btn dialog-btn-secondary" onclick="cancelPlacement()">Cancel</button>
            <button class="dialog-btn dialog-btn-primary" onclick="confirmPlacement()">Place</button>
        </div>
    </div>

    <script>
        const state = {
            currentView: '2d',
            rooms: [],
            currentRoomIndex: 0,
            currentFeature: null,
            zoom: 1,
            panX: 0,
            panY: 0,
            wallSelectionMode: false,
            pendingFeature: null,
            selectedWall: null,
            hoveredWall: null,
            clickPoint: null,
            showAllRooms: false,
            draggingRoom: null,
            dragStartX: 0,
            dragStartY: 0,
            dragStartRoomX: 0,
            dragStartRoomZ: 0,
            lastSnapped: false,
            snapType: '',
            draggingFeature: null,
            draggingFeatureType: null,
            draggingFeatureIndex: null,
            draggingFeatureWallIndex: null,
            potentialDragFeature: null,  // For tap vs drag detection
            potentialDragType: null,
            potentialDragIndex: null,
            potentialDragWallIndex: null,
            projectName: 'Untitled Project'
        };
        
        // Undo system
        const undoStack = [];
        const maxUndoSteps = 50;
        
        function saveStateForUndo() {
            // Deep clone the rooms array
            const snapshot = JSON.parse(JSON.stringify(state.rooms));
            undoStack.push(snapshot);
            
            // Limit undo stack size
            if (undoStack.length > maxUndoSteps) {
                undoStack.shift();
            }
            
            console.log('Saved undo state, stack size:', undoStack.length);
        }
        
        function undo() {
            if (undoStack.length === 0) {
                showToast('‚ö†Ô∏è Nothing to undo');
                return;
            }
            
            // Pop the last state
            const previousState = undoStack.pop();
            state.rooms = previousState;
            
            console.log('Undo performed, stack size:', undoStack.length);
            showToast('‚Ü∂ Undo');
            
            updateRoomList();
            redraw2D();
            if (state.currentView === '3d') {
                render3D();
            }
            updateStats();
        }

        const canvas2D = document.getElementById('canvas2D');
        const ctx = canvas2D.getContext('2d');
        
        // Global click tracker for debugging
        window.addEventListener('click', (e) => {
            if (state.currentView === '3d') {
                console.log('üîç GLOBAL CLICK DETECTED in 3D mode');
                console.log('  Target:', e.target.tagName, e.target.id, e.target.className);
                console.log('  Position:', e.clientX, e.clientY);
                console.log('  Current scene children:', scene ? scene.children.length : 'scene not initialized');
            }
        }, true); // Capture phase to see ALL clicks
        let scene, camera, renderer;

        window.addEventListener('load', () => {
            console.log('Initializing Cochran Claims Tool...');
            
            resizeCanvas();
            init3D();
            
            // Create default room
            addNewRoom('Living Room');
            
            generateWallInputs();
            updateRoomList();
            updateModeIndicator();
            
            console.log('Tool ready!');
        });

        window.addEventListener('resize', resizeCanvas);

        // Mouse wheel zoom for 2D canvas
        canvas2D.addEventListener('wheel', (e) => {
            if (state.currentView !== '2d') return; // Only handle in 2D mode
            
            e.preventDefault();
            const rect = canvas2D.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Zoom towards mouse position
            const worldX = (mouseX - state.panX) / state.zoom;
            const worldY = (mouseY - state.panY) / state.zoom;
            
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(5, state.zoom * delta));
            
            // Adjust pan to keep mouse position stable
            state.panX = mouseX - worldX * newZoom;
            state.panY = mouseY - worldY * newZoom;
            state.zoom = newZoom;
            
            document.getElementById('zoomLevel').textContent = Math.round(state.zoom * 100) + '%';
            redraw2D();
        });

        // Mouse drag for panning 2D canvas
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let panStartPanX = 0;
        let panStartPanY = 0;
        
        // Hover state for delete mode
        let hoverClickPoint = null;
        let hoverDoorIndex = null;
        let hoverWindowIndex = null;

        canvas2D.addEventListener('mousedown', (e) => {
            if (state.currentView !== '2d') return; // Only handle in 2D mode
            
            const rect = canvas2D.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            const x = (clickX - state.panX) / state.zoom;
            const y = (clickY - state.panY) / state.zoom;
            
            // Check for feature dragging (doors, windows, missing walls) - only if not shift or middle button
            if (e.button === 0 && !e.shiftKey && !state.wallSelectionMode && !state.currentFeature) {
                const room = getCurrentRoom();
                if (room) {
                    // Check doors
                    for (let i = room.doors.length - 1; i >= 0; i--) {
                        const door = room.doors[i];
                        const dist = Math.sqrt(Math.pow(x - door.x, 2) + Math.pow(y - door.y, 2));
                        if (dist < 50) {
                            saveStateForUndo();
                            state.draggingFeature = door;
                            state.draggingFeatureType = 'door';
                            state.draggingFeatureIndex = i;
                            canvas2D.style.cursor = 'grabbing';
                            e.preventDefault();
                            return;
                        }
                    }
                    
                    // Check windows
                    for (let i = room.windows.length - 1; i >= 0; i--) {
                        const win = room.windows[i];
                        const dist = Math.sqrt(Math.pow(x - win.x, 2) + Math.pow(y - win.y, 2));
                        if (dist < 50) {
                            saveStateForUndo();
                            state.draggingFeature = win;
                            state.draggingFeatureType = 'window';
                            state.draggingFeatureIndex = i;
                            canvas2D.style.cursor = 'grabbing';
                            e.preventDefault();
                            return;
                        }
                    }
                    
                    // Check missing walls
                    const hitMissing = findMissingAtPoint(room, x, y);
                    if (hitMissing) {
                        const wall = room.walls[hitMissing.wallIdx];
                        if (wall && wall.missingWalls && wall.missingWalls[hitMissing.missIdx]) {
                            saveStateForUndo();
                            state.draggingFeature = wall.missingWalls[hitMissing.missIdx];
                            state.draggingFeatureType = 'missing';
                            state.draggingFeatureIndex = hitMissing.missIdx;
                            state.draggingFeatureWallIndex = hitMissing.wallIdx;
                            canvas2D.style.cursor = 'grabbing';
                            e.preventDefault();
                            return;
                        }
                    }
                }
            }
            
            // Room dragging in show all rooms mode
            if (state.showAllRooms && e.button === 0 && !e.shiftKey) {
                // Check if clicking on any room
                for (let i = state.rooms.length - 1; i >= 0; i--) {
                    const room = state.rooms[i];
                    if (room.floorPoints.length < 3) continue;
                    
                    const offsetX = (room.positionX || 0) * 30;
                    const offsetZ = (room.positionZ || 0) * 30;
                    
                    // Check if point is inside room polygon
                    let inside = false;
                    for (let j = 0, k = room.floorPoints.length - 1; j < room.floorPoints.length; k = j++) {
                        const xi = room.floorPoints[j].x + offsetX;
                        const yi = room.floorPoints[j].y + offsetZ;
                        const xk = room.floorPoints[k].x + offsetX;
                        const yk = room.floorPoints[k].y + offsetZ;
                        
                        if ((yi > y) !== (yk > y) && x < (xk - xi) * (y - yi) / (yk - yi) + xi) {
                            inside = !inside;
                        }
                    }
                    
                    if (inside) {
                        state.draggingRoom = i;
                        state.dragStartX = x;
                        state.dragStartY = y;
                        state.dragStartRoomX = room.positionX || 0;
                        state.dragStartRoomZ = room.positionZ || 0;
                        state.currentRoomIndex = i;
                        canvas2D.style.cursor = 'move';
                        updateRoomList();
                        redraw2D();
                        return;
                    }
                }
            }
            
            // Middle mouse button or Shift+Left button = pan
            if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                e.preventDefault();
                isPanning = true;
                panStartX = e.clientX;
                panStartY = e.clientY;
                panStartPanX = state.panX;
                panStartPanY = state.panY;
                canvas2D.style.cursor = 'grabbing';
            }
        });

        canvas2D.addEventListener('mousemove', (e) => {
            if (state.currentView !== '2d') return; // Only handle in 2D mode
            
            const rect = canvas2D.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            const x = (clickX - state.panX) / state.zoom;
            const y = (clickY - state.panY) / state.zoom;
            
            if (isPanning) {
                const dx = e.clientX - panStartX;
                const dy = e.clientY - panStartY;
                state.panX = panStartPanX + dx;
                state.panY = panStartPanY + dy;
                redraw2D();
                return; // Don't do hover detection while panning
            }
            
            // Feature dragging (doors, windows, missing walls)
            if (state.draggingFeature) {
                const room = getCurrentRoom();
                if (!room) return;
                
                if (state.draggingFeatureType === 'door' || state.draggingFeatureType === 'window') {
                    const feature = state.draggingFeatureType === 'door' ? room.doors[state.draggingFeatureIndex] : room.windows[state.draggingFeatureIndex];
                    if (!feature) return;
                    
                    const wall = room.walls[feature.wallIndex];
                    if (!wall) return;
                    
                    // Find closest point on the wall to the mouse
                    const wallDx = wall.end.x - wall.start.x;
                    const wallDy = wall.end.y - wall.start.y;
                    const wallLength = Math.sqrt(wallDx * wallDx + wallDy * wallDy);
                    
                    // Project mouse position onto wall
                    const mouseToWallStartX = x - wall.start.x;
                    const mouseToWallStartY = y - wall.start.y;
                    const projection = (mouseToWallStartX * wallDx + mouseToWallStartY * wallDy) / (wallLength * wallLength);
                    const clampedProjection = Math.max(0, Math.min(1, projection));
                    
                    // Calculate new position on wall
                    feature.x = wall.start.x + clampedProjection * wallDx;
                    feature.y = wall.start.y + clampedProjection * wallDy;
                    
                    // Update distanceFromLeft
                    const wallLengthFt = parseFloat(wall.length);
                    const featureWidthFt = feature.width / 12;
                    const distanceFromStartFt = clampedProjection * wallLengthFt;
                    const edgePosition = distanceFromStartFt - (featureWidthFt / 2);
                    feature.distanceFromLeft = Math.max(0, Math.min(wallLengthFt - featureWidthFt, edgePosition));
                    
                    redraw2D();
                    return;
                    
                } else if (state.draggingFeatureType === 'missing') {
                    const wall = room.walls[state.draggingFeatureWallIndex];
                    const missing = wall.missingWalls[state.draggingFeatureIndex];
                    if (!wall || !missing) return;
                    
                    // Find closest point on the wall to the mouse
                    const wallDx = wall.end.x - wall.start.x;
                    const wallDy = wall.end.y - wall.start.y;
                    const wallLength = Math.sqrt(wallDx * wallDx + wallDy * wallDy);
                    
                    // Project mouse position onto wall
                    const mouseToWallStartX = x - wall.start.x;
                    const mouseToWallStartY = y - wall.start.y;
                    const projection = (mouseToWallStartX * wallDx + mouseToWallStartY * wallDy) / (wallLength * wallLength);
                    const clampedProjection = Math.max(0, Math.min(1, projection));
                    
                    // Calculate the missing wall segment width
                    const missingWidth = missing.endDist - missing.startDist;
                    const wallLengthFt = parseFloat(wall.length);
                    const centerDistFt = clampedProjection * wallLengthFt;
                    const newStartDist = Math.max(0, centerDistFt - missingWidth / 2);
                    const newEndDist = Math.min(wallLengthFt, newStartDist + missingWidth);
                    
                    missing.startDist = newStartDist;
                    missing.endDist = newEndDist;
                    
                    redraw2D();
                    return;
                }
            }
            
            // Room dragging
            if (state.draggingRoom !== null) {
                const room = state.rooms[state.draggingRoom];
                const dx = (x - state.dragStartX) / 30; // Convert pixels to position units
                const dy = (y - state.dragStartY) / 30;
                
                let newX = state.dragStartRoomX + dx;
                let newZ = state.dragStartRoomZ + dy;
                
                // Calculate room bounds for snapping
                if (room.floorPoints.length >= 3) {
                    let minX = Infinity, maxX = -Infinity;
                    let minZ = Infinity, maxZ = -Infinity;
                    
                    room.floorPoints.forEach(p => {
                        minX = Math.min(minX, p.x / 30);
                        maxX = Math.max(maxX, p.x / 30);
                        minZ = Math.min(minZ, p.y / 30);
                        maxZ = Math.max(maxZ, p.y / 30);
                    });
                    
                    const roomWidth = maxX - minX;
                    const roomDepth = maxZ - minZ;
                    
                    // Calculate this room's corners in world space
                    // Account for the room's origin offset from its bounding box
                    const myCorners = [
                        { x: newX + minX, z: newZ + minZ, name: 'TL' },                                    // Top-left
                        { x: newX + maxX, z: newZ + minZ, name: 'TR' },                                    // Top-right
                        { x: newX + maxX, z: newZ + maxZ, name: 'BR' },                                    // Bottom-right
                        { x: newX + minX, z: newZ + maxZ, name: 'BL' }                                     // Bottom-left
                    ];
                    
                    // Check for snapping to other rooms
                    const snapTolerance = 1.0; // Snap if within 1 foot
                    let snapped = false;
                    let snapType = '';
                    
                    state.rooms.forEach((otherRoom, idx) => {
                        if (idx === state.draggingRoom || otherRoom.floorPoints.length < 3) return;
                        
                        let otherMinX = Infinity, otherMaxX = -Infinity;
                        let otherMinZ = Infinity, otherMaxZ = -Infinity;
                        
                        otherRoom.floorPoints.forEach(p => {
                            otherMinX = Math.min(otherMinX, p.x / 30);
                            otherMaxX = Math.max(otherMaxX, p.x / 30);
                            otherMinZ = Math.min(otherMinZ, p.y / 30);
                            otherMaxZ = Math.max(otherMaxZ, p.y / 30);
                        });
                        
                        const otherX = (otherRoom.positionX || 0);
                        const otherZ = (otherRoom.positionZ || 0);
                        const otherWidth = otherMaxX - otherMinX;
                        const otherDepth = otherMaxZ - otherMinZ;
                        
                        // Other room's corners in world space
                        const otherCorners = [
                            { x: otherX + otherMinX, z: otherZ + otherMinZ, name: 'TL' },
                            { x: otherX + otherMaxX, z: otherZ + otherMinZ, name: 'TR' },
                            { x: otherX + otherMaxX, z: otherZ + otherMaxZ, name: 'BR' },
                            { x: otherX + otherMinX, z: otherZ + otherMaxZ, name: 'BL' }
                        ];
                        
                        // CORNER TO CORNER SNAPPING (highest priority)
                        if (!snapped) {
                            for (let i = 0; i < myCorners.length && !snapped; i++) {
                                for (let j = 0; j < otherCorners.length && !snapped; j++) {
                                    const dist = Math.sqrt(
                                        Math.pow(myCorners[i].x - otherCorners[j].x, 2) + 
                                        Math.pow(myCorners[i].z - otherCorners[j].z, 2)
                                    );
                                    
                                    if (dist < snapTolerance * 1.5) {
                                        // Snap this corner to that corner
                                        const offsetX = otherCorners[j].x - myCorners[i].x;
                                        const offsetZ = otherCorners[j].z - myCorners[i].z;
                                        newX += offsetX;
                                        newZ += offsetZ;
                                        snapped = true;
                                        snapType = '‚ö° CORNER';
                                        
                                        // Update corner positions after snap
                                        myCorners[0] = { x: newX + minX, z: newZ + minZ };
                                        myCorners[1] = { x: newX + maxX, z: newZ + minZ };
                                        myCorners[2] = { x: newX + maxX, z: newZ + maxZ };
                                        myCorners[3] = { x: newX + minX, z: newZ + maxZ };
                                        
                                        break; // Found a snap, stop checking
                                    }
                                }
                            }
                        }
                        
                        // EDGE TO EDGE SNAPPING (if no corner snap)
                        if (!snapped) {
                            // My room's edges
                            const myLeft = newX + minX;
                            const myRight = newX + maxX;
                            const myTop = newZ + minZ;
                            const myBottom = newZ + maxZ;
                            
                            // Other room's edges
                            const otherLeft = otherX + otherMinX;
                            const otherRight = otherX + otherMaxX;
                            const otherTop = otherZ + otherMinZ;
                            const otherBottom = otherZ + otherMaxZ;
                            
                            // Snap right edge to left edge of other room
                            if (Math.abs(myRight - otherLeft) < snapTolerance) {
                                newX = otherLeft - maxX;
                                snapped = true;
                                snapType = '‚ö° EDGE';
                            }
                            // Snap left edge to right edge of other room
                            if (Math.abs(myLeft - otherRight) < snapTolerance) {
                                newX = otherRight - minX;
                                snapped = true;
                                snapType = '‚ö° EDGE';
                            }
                            // Snap bottom edge to top edge of other room
                            if (Math.abs(myBottom - otherTop) < snapTolerance) {
                                newZ = otherTop - maxZ;
                                snapped = true;
                                snapType = '‚ö° EDGE';
                            }
                            // Snap top edge to bottom edge of other room
                            if (Math.abs(myTop - otherBottom) < snapTolerance) {
                                newZ = otherBottom - minZ;
                                snapped = true;
                                snapType = '‚ö° EDGE';
                            }
                        }
                    });
                    
                    state.snapType = snapType;
                    
                    if (snapped) {
                        canvas2D.style.cursor = 'crosshair';
                        state.lastSnapped = true;
                    } else {
                        canvas2D.style.cursor = 'move';
                        state.lastSnapped = false;
                    }
                }
                
                room.positionX = newX;
                room.positionZ = newZ;
                
                // Update position inputs
                document.getElementById('roomPosX').value = Math.round(room.positionX);
                document.getElementById('roomPosZ').value = Math.round(room.positionZ);
                
                redraw2D();
                if (state.currentView === '3d') {
                    render3D();
                }
                return;
            }
            
            // Existing hover detection code continues below...
            const room = getCurrentRoom();
            if (!room) return;
            
            // Always reset hover states first
            const prevHoverDoor = hoverDoorIndex;
            const prevHoverWindow = hoverWindowIndex;
            hoverDoorIndex = null;
            hoverWindowIndex = null;
            hoverClickPoint = null;
            
            // Check if hovering over door or window when not in wall selection mode and no feature selected
            if (!state.wallSelectionMode && !state.currentFeature) {
                // Check doors - always check regardless of other conditions
                for (let i = 0; i < room.doors.length; i++) {
                    const door = room.doors[i];
                    const dist = Math.sqrt(Math.pow(x - door.x, 2) + Math.pow(y - door.y, 2));
                    if (dist < 50) { // Increased to 50 pixels for easier detection
                        hoverDoorIndex = i;
                        canvas2D.style.cursor = 'grab';
                        if (prevHoverDoor !== i) redraw2D();
                        return;
                    }
                }
                
                // Check windows
                for (let i = 0; i < room.windows.length; i++) {
                    const win = room.windows[i];
                    const dist = Math.sqrt(Math.pow(x - win.x, 2) + Math.pow(y - win.y, 2));
                    if (dist < 50) { // Increased to 50 pixels
                        hoverWindowIndex = i;
                        canvas2D.style.cursor = 'grab';
                        if (prevHoverWindow !== i) redraw2D();
                        return;
                    }
                }
                
                // Check missing walls
                const hitMissing = findMissingAtPoint(room, x, y);
                if (hitMissing) {
                    canvas2D.style.cursor = 'grab';
                    return;
                }
                
                canvas2D.style.cursor = 'default';
                if (prevHoverDoor !== null || prevHoverWindow !== null) {
                    redraw2D(); // Clear previous hover highlight
                }
                return;
            }
            
            // Wall selection mode - show placement indicator
            if (state.wallSelectionMode) {
                canvas2D.style.cursor = 'default';
                
                // Find closest wall and point on wall
                let hoveredWall = null;
                let minDist = Infinity;
                let closestPoint = null;
                
                room.walls.forEach((wall, index) => {
                    const dist = distanceToLineSegment(x, y, wall.start.x, wall.start.y, wall.end.x, wall.end.y);
                    if (dist < 30 && dist < minDist) {
                        minDist = dist;
                        hoveredWall = index;
                        
                        // Calculate closest point on wall
                        const A = x - wall.start.x;
                        const B = y - wall.start.y;
                        const C = wall.end.x - wall.start.x;
                        const D = wall.end.y - wall.start.y;
                        
                        const dot = A * C + B * D;
                        const lenSq = C * C + D * D;
                        let param = -1;
                        if (lenSq !== 0) param = dot / lenSq;
                        param = Math.max(0, Math.min(1, param));
                        
                        closestPoint = {
                            x: wall.start.x + param * C,
                            y: wall.start.y + param * D
                        };
                    }
                });
                
                // Update cursor
                canvas2D.style.cursor = hoveredWall !== null ? 'pointer' : 'default';
                
                // Store hover point for drawing
                hoverClickPoint = closestPoint;
                
                if (state.hoveredWall !== hoveredWall) {
                    state.hoveredWall = hoveredWall;
                    redraw2D();
                } else if (hoverClickPoint) {
                    redraw2D(); // Redraw to show the point indicator
                }
            }
        });

        function resizeCanvas() {
            const area = document.getElementById('canvasArea');
            canvas2D.width = area.clientWidth;
            canvas2D.height = area.clientHeight;
            if (renderer) {
                renderer.setSize(area.clientWidth, area.clientHeight);
                camera.aspect = area.clientWidth / area.clientHeight;
                camera.updateProjectionMatrix();
            }
            
            // Only redraw the current view
            if (state.currentView === '2d') {
                redraw2D();
            } else if (state.currentView === '3d' && renderer) {
                renderer.render(scene, camera);
            }
        }

        function init3D() {
            console.log('=== Initializing 3D ===');
            const container = document.getElementById('canvas3D');
            const area = document.getElementById('canvasArea');
            
            console.log('Container:', container);
            console.log('Area dimensions:', area.clientWidth, 'x', area.clientHeight);
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Monitor scene modifications
            const originalRemove = scene.remove.bind(scene);
            scene.remove = function(...args) {
                console.log('Scene.remove called, current children:', scene.children.length, 'removing:', args.length);
                const result = originalRemove(...args);
                console.log('After remove, children:', scene.children.length);
                return result;
            };
            
            camera = new THREE.PerspectiveCamera(60, area.clientWidth / area.clientHeight, 0.1, 1000);
            // Pull camera way back and up for full room view
            camera.position.set(25, 25, 35);
            camera.lookAt(0, 3, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(area.clientWidth, area.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);
            
            // Ensure the canvas has proper styling for events
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.width = '100%';
            renderer.domElement.style.height = '100%';
            renderer.domElement.style.pointerEvents = 'auto';
            
            console.log('Renderer created, canvas size:', renderer.domElement.width, 'x', renderer.domElement.height);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Increased brightness
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0); // Increased brightness
            dirLight.position.set(30, 50, 30);
            dirLight.castShadow = true;
            scene.add(dirLight);
            
            // Ground plane removed - no floor in 3D view
            
            console.log('Scene has', scene.children.length, 'initial children');
            
            setupOrbitControls();
            console.log('=== 3D initialization complete ===');
        }

        function setupOrbitControls() {
            const canvas = renderer.domElement;
            
            // ORBIT CAMERA - rotates around a fixed target point
            let targetX = 0;  // Will be set to room center by render3D
            let targetY = 4;  // Middle height of room (4 feet)
            let targetZ = 0;  // Will be set to room center by render3D
            
            let radius = 15;  // Distance from target
            let theta = Math.PI;    // Horizontal angle (radians) - rotated 180¬∞ to unmirror
            let phi = Math.PI / 3; // Vertical angle (60 degrees from vertical)
            
            const rotateSpeed = 0.008;
            const zoomSpeed = 0.3;
            const panSpeed = 0.1;
            
            // Track keys and mouse
            const keys = {};
            let isMouseDown = false;
            let isRightMouseDown = false;
            let lastMouseX = 0;
            let lastMouseY = 0;
            
            // Update camera position based on spherical coordinates
            function updateCameraPosition() {
                // Convert spherical to cartesian coordinates
                camera.position.x = targetX + radius * Math.sin(phi) * Math.sin(theta);
                camera.position.y = targetY + radius * Math.cos(phi);
                camera.position.z = targetZ + radius * Math.sin(phi) * Math.cos(theta);
                
                // Always look at the target
                camera.lookAt(targetX, targetY, targetZ);
            }
            
            // Function to set orbit target (called by render3D)
            window.setOrbitTarget = function(x, y, z) {
                targetX = x;
                targetY = y;
                targetZ = z;
                console.log(`üéØ Orbit target set to: (${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)})`);
                updateCameraPosition();
            };
            
            // Function to update camera distance (called by render3D for auto-zoom)
            window.updateCameraRadius = function(newRadius) {
                radius = Math.max(5, Math.min(50, newRadius)); // Clamp between 5 and 50
                updateCameraPosition();
            };
            
            // Function to reset camera to default viewing angle
            window.resetCameraView = function() {
                theta = Math.PI;    // Face the room straight on
                phi = Math.PI / 3;  // 60 degrees from vertical
                radius = 15;        // Default distance
                console.log(`üîÑ Camera reset: theta=${theta.toFixed(2)}, phi=${phi.toFixed(2)}, radius=${radius}`);
                updateCameraPosition();
                console.log(`üì∑ Camera now at: (${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)})`);
            };
            
            // Keyboard events
            window.addEventListener('keydown', (e) => {
                // Ctrl+Z for undo
                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    e.stopPropagation();
                    undo();
                    return;
                }
                
                if (state.currentView === '3d') {
                    keys[e.key.toLowerCase()] = true;
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
            
            window.addEventListener('keyup', (e) => {
                if (state.currentView === '3d') {
                    keys[e.key.toLowerCase()] = false;
                }
            });
            
            // Mouse drag to orbit (left) or pan (right)
            canvas.addEventListener('mousedown', (e) => {
                if (state.currentView === '3d') {
                    if (e.button === 0) { // Left button - orbit
                        isMouseDown = true;
                    } else if (e.button === 2) { // Right button - pan
                        isRightMouseDown = true;
                    }
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (state.currentView === '3d') {
                    if (e.button === 0) {
                        isMouseDown = false;
                    } else if (e.button === 2) {
                        isRightMouseDown = false;
                    }
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (state.currentView === '3d') {
                    isMouseDown = false;
                    isRightMouseDown = false;
                }
            });
            
            canvas.addEventListener('click', (e) => {
                if (state.currentView === '3d') {
                    e.stopPropagation();
                    e.preventDefault();
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (state.currentView === '3d' && (isMouseDown || isRightMouseDown)) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;
                    
                    if (isRightMouseDown) {
                        // Right-click: Pan the target
                        // Calculate right vector (perpendicular to view direction)
                        const right = new THREE.Vector3();
                        right.set(Math.cos(theta), 0, -Math.sin(theta));
                        
                        const panAmount = 0.05;
                        targetX -= right.x * deltaX * panAmount;
                        targetZ -= right.z * deltaX * panAmount;
                        targetY += deltaY * panAmount;
                        
                        updateCameraPosition();
                    } else if (isMouseDown) {
                        // Left-click: Rotate around target
                        theta -= deltaX * rotateSpeed;
                        phi -= deltaY * rotateSpeed;
                        
                        // Clamp phi to prevent flipping
                        phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
                        
                        updateCameraPosition();
                    }
                    
                    renderer.render(scene, camera);
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    
                    e.stopPropagation();
                    e.preventDefault();
                }
            });
            
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            // Mouse wheel to zoom (change radius)
            canvas.addEventListener('wheel', (e) => {
                if (state.currentView === '3d') {
                    e.preventDefault();
                    
                    radius += e.deltaY * zoomSpeed;
                    radius = Math.max(3, Math.min(100, radius)); // Clamp between 3 and 100
                    
                    updateCameraPosition();
                    renderer.render(scene, camera);
                }
            });
            
            // Animation loop for keyboard panning
            function animate() {
                requestAnimationFrame(animate);
                
                if (state.currentView !== '3d') return;
                
                let moved = false;
                
                // WASD/Arrow keys pan the target (what we're looking at)
                if (keys['w'] || keys['arrowup']) {
                    targetZ -= panSpeed;
                    moved = true;
                }
                if (keys['s'] || keys['arrowdown']) {
                    targetZ += panSpeed;
                    moved = true;
                }
                if (keys['a'] || keys['arrowleft']) {
                    targetX -= panSpeed;
                    moved = true;
                }
                if (keys['d'] || keys['arrowright']) {
                    targetX += panSpeed;
                    moved = true;
                }
                if (keys['q']) {
                    targetY += panSpeed;
                    moved = true;
                }
                if (keys['e']) {
                    targetY -= panSpeed;
                    moved = true;
                }
                
                if (moved) {
                    updateCameraPosition();
                    renderer.render(scene, camera);
                }
            }
            animate();
            
            // Touch support
            let touchStart = null;
            let touchStartDistance = null;
            
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                }
            }, { passive: false });
            
            canvas.addEventListener('touchmove', (e) => {
                if (state.currentView === '3d') {
                    e.preventDefault();
                    
                    if (e.touches.length === 1 && touchStart) {
                        const dx = e.touches[0].clientX - touchStart.x;
                        const dy = e.touches[0].clientY - touchStart.y;
                        
                        theta -= dx * rotateSpeed;
                        phi -= dy * rotateSpeed;
                        phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
                        
                        updateCameraPosition();
                        renderer.render(scene, camera);
                        
                        touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    } else if (e.touches.length === 2 && touchStartDistance) {
                        const dx = e.touches[0].clientX - e.touches[1].clientX;
                        const dy = e.touches[0].clientY - e.touches[1].clientY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const delta = touchStartDistance - distance;
                        
                        radius += delta * 0.05;
                        radius = Math.max(3, Math.min(100, radius));
                        
                        updateCameraPosition();
                        renderer.render(scene, camera);
                        
                        touchStartDistance = distance;
                    }
                }
            }, { passive: false });
            
            canvas.addEventListener('touchend', () => {
                touchStart = null;
                touchStartDistance = null;
            }, { passive: false });
            
            window.updateCameraTarget = function() {};
        }


        function addNewRoom(name) {
            // If called without a name (from button click), show modal
            if (!name) {
                showAddRoomModal();
                return;
            }
            
            state.rooms.push({
                name,
                floorPoints: [],
                walls: [],
                ceilingHeight: 8.0,
                wallThickness: 4,
                doors: [],
                windows: [],
                damageMarkers: [],
                openings: [],  // Track wall cuts/openings
                positionX: state.rooms.length * 30, // Default spacing
                positionZ: 0
            });
            
            updateRoomList();
            redraw2D();
            showToast(`‚úì Room "${name}" added - Click to switch to it`);
        }

        function switchRoom(index) {
            state.currentRoomIndex = index;
            updateRoomList();
            
            // Update position inputs
            const room = getCurrentRoom();
            if (room) {
                document.getElementById('roomPosX').value = room.positionX || 0;
                document.getElementById('roomPosZ').value = room.positionZ || 0;
            }
            
            redraw2D();
            updateStats();
        }

        function updateRoomPosition() {
            const room = getCurrentRoom();
            if (!room) return;
            
            room.positionX = parseFloat(document.getElementById('roomPosX').value) || 0;
            room.positionZ = parseFloat(document.getElementById('roomPosZ').value) || 0;
            
            if (state.currentView === '3d') {
                render3D();
            }
            showToast(`üìç Position: (${room.positionX}, ${room.positionZ})`);
        }

        function resetRoomPosition() {
            const room = getCurrentRoom();
            if (!room) return;
            
            room.positionX = state.currentRoomIndex * 30;
            room.positionZ = 0;
            
            document.getElementById('roomPosX').value = room.positionX;
            document.getElementById('roomPosZ').value = room.positionZ;
            
            if (state.currentView === '3d') {
                render3D();
            }
            showToast('üìç Position reset');
        }

        function deleteRoom(index) {
            if (state.rooms.length === 1) {
                showToast('‚ùå Cannot delete last room');
                return;
            }
            if (confirm(`Delete "${state.rooms[index].name}"?`)) {
                state.rooms.splice(index, 1);
                state.currentRoomIndex = Math.min(state.currentRoomIndex, state.rooms.length - 1);
                updateRoomList();
                redraw2D();
            }
        }

        let editingRoomIndex = null;

        function showEditNameModal(roomIndex) {
            editingRoomIndex = roomIndex;
            const room = state.rooms[roomIndex];
            const modal = document.getElementById('editNameModal');
            const input = document.getElementById('editNameInput');
            
            input.value = room.name;
            modal.style.display = 'flex';
            
            // Focus and select text after modal is visible
            setTimeout(() => {
                input.focus();
                input.select();
            }, 100);
            
            // Allow Enter key to submit
            input.onkeypress = function(e) {
                if (e.key === 'Enter') {
                    confirmEditName();
                }
            };
        }

        function cancelEditName() {
            document.getElementById('editNameModal').style.display = 'none';
            editingRoomIndex = null;
        }

        function confirmEditName() {
            const newName = document.getElementById('editNameInput').value.trim();
            
            if (newName && editingRoomIndex !== null) {
                const room = state.rooms[editingRoomIndex];
                if (newName !== room.name) {
                    room.name = newName;
                    updateRoomList();
                    redraw2D();
                    showToast(`‚úèÔ∏è Room renamed to "${newName}"`);
                }
            }
            
            document.getElementById('editNameModal').style.display = 'none';
            editingRoomIndex = null;
        }

        function showAddRoomModal() {
            const modal = document.getElementById('addRoomModal');
            const input = document.getElementById('addRoomInput');
            
            input.value = `Room ${state.rooms.length + 1}`;
            modal.style.display = 'flex';
            
            // Focus and select text after modal is visible
            setTimeout(() => {
                input.focus();
                input.select();
            }, 100);
            
            // Allow Enter key to submit
            input.onkeypress = function(e) {
                if (e.key === 'Enter') {
                    confirmAddRoom();
                }
            };
        }

        function cancelAddRoom() {
            document.getElementById('addRoomModal').style.display = 'none';
        }

        function confirmAddRoom() {
            const name = document.getElementById('addRoomInput').value.trim() || `Room ${state.rooms.length + 1}`;
            
            console.log('===== ADDING NEW ROOM =====');
            console.log('Room name:', name);
            
            state.rooms.push({
                name,
                floorPoints: [],
                walls: [],
                ceilingHeight: 8.0,
                wallThickness: 4,
                doors: [],
                windows: [],
                damageMarkers: [],
                openings: [],  // Track wall cuts/openings
                positionX: state.rooms.length * 30,
                positionZ: 0
            });
            
            updateRoomList();
            redraw2D();
            showToast(`‚úì Room "${name}" added - Click to switch to it`);
            
            document.getElementById('addRoomModal').style.display = 'none';
        }

        // Position Modal Functions
        let positionFeatureType = null;
        let positionFeatureIndex = null;
        let positionWallIndex = null;
        let cutWallRoomIndex = null;
        let editingCut = null;
function showPositionModal(featureType, featureIndex) {
            const room = getCurrentRoom();
            if (!room) return;
            
            const feature = featureType === 'door' ? room.doors[featureIndex] : room.windows[featureIndex];
            if (!feature) return;
            
            positionFeatureType = featureType;
            positionFeatureIndex = featureIndex;
            positionWallIndex = feature.wallIndex;
            
            const wall = room.walls[feature.wallIndex];
            const wallLength = parseFloat(wall.length);
            const featureWidthFt = feature.width / 12; // Convert inches to feet
            
            // Update modal content
            const icon = featureType === 'door' ? 'üö™' : 'ü™ü';
            const typeName = featureType === 'door' ? 'Door' : 'Window';
            
            document.getElementById('positionModalTitle').textContent = `üìè Edit ${typeName}`;
            document.getElementById('positionCurrentWall').textContent = wall.name;
            document.getElementById('positionWallLength').textContent = `${wallLength.toFixed(1)} ft`;
            document.getElementById('positionFeatureWidth').textContent = `${featureWidthFt.toFixed(2)} ft`;
            document.getElementById('positionCurrentPos').textContent = `${feature.distanceFromLeft.toFixed(2)} ft`;
            
            // Position input
            const posInput = document.getElementById('positionInput');
            const referenceCorner = feature.referenceCorner || 'left'; // Default to left if not set
            document.getElementById('positionReferenceCorner').value = referenceCorner;
            
            // Set distance based on reference corner
            if (referenceCorner === 'right') {
                const distanceFromRight = wallLength - feature.distanceFromLeft - featureWidthFt;
                posInput.value = distanceFromRight.toFixed(2);
                document.getElementById('positionDistanceLabel').textContent = 'Distance to Left Edge from Right (feet):';
            } else {
                posInput.value = feature.distanceFromLeft.toFixed(2);
                document.getElementById('positionDistanceLabel').textContent = 'Distance to Left Edge from Left (feet):';
            }
            posInput.max = wallLength - featureWidthFt;
            
            // Width input
            const widthInput = document.getElementById('positionWidthInput');
            widthInput.value = feature.width;
            
            // Height fields
            const heightFields = document.getElementById('positionHeightFields');
            if (featureType === 'window') {
                heightFields.style.display = 'block';
                const heightInput = document.getElementById('positionHeightInput');
                const floorHeightInput = document.getElementById('positionFloorHeightInput');
                heightInput.value = feature.height || 36; // Default 36" (3.0 feet) if not set
                floorHeightInput.value = feature.heightFromFloor || 3.0; // Default 3.0 ft
                document.querySelector('#positionHeightFields label[for="positionHeightInput"]').textContent = 'Window Height (inches)';
                document.getElementById('positionFloorHeightFields').style.display = 'block';
            } else if (featureType === 'door') {
                heightFields.style.display = 'block';
                const heightInput = document.getElementById('positionHeightInput');
                heightInput.value = feature.height || 80; // Default 80" (6'8") if not set
                document.querySelector('#positionHeightFields label[for="positionHeightInput"]').textContent = 'Door Height (inches)';
                document.getElementById('positionFloorHeightFields').style.display = 'none';
                
                // Show door swing selector
                const swingFields = document.getElementById('positionDoorSwingFields');
                swingFields.style.display = 'block';
                
                // Get current settings
                const currentHinge = feature.hinge || 'right';
                const currentSwingDir = feature.swingDirection || 'in';
                
                // Get all buttons
                const hingeLeftBtn = document.getElementById('hingeLeftBtn');
                const hingeRightBtn = document.getElementById('hingeRightBtn');
                const swingInBtn = document.getElementById('swingInBtn');
                const swingOutBtn = document.getElementById('swingOutBtn');
                
                // Highlight hinge side
                if (currentHinge === 'left') {
                    hingeLeftBtn.style.background = '#4CAF50';
                    hingeLeftBtn.style.color = 'white';
                    hingeLeftBtn.style.borderColor = '#4CAF50';
                    hingeRightBtn.style.background = 'white';
                    hingeRightBtn.style.color = '#333';
                    hingeRightBtn.style.borderColor = '#ddd';
                } else {
                    hingeRightBtn.style.background = '#4CAF50';
                    hingeRightBtn.style.color = 'white';
                    hingeRightBtn.style.borderColor = '#4CAF50';
                    hingeLeftBtn.style.background = 'white';
                    hingeLeftBtn.style.color = '#333';
                    hingeLeftBtn.style.borderColor = '#ddd';
                }
                
                // Highlight swing direction
                if (currentSwingDir === 'in') {
                    swingInBtn.style.background = '#4CAF50';
                    swingInBtn.style.color = 'white';
                    swingInBtn.style.borderColor = '#4CAF50';
                    swingOutBtn.style.background = 'white';
                    swingOutBtn.style.color = '#333';
                    swingOutBtn.style.borderColor = '#ddd';
                } else {
                    swingOutBtn.style.background = '#4CAF50';
                    swingOutBtn.style.color = 'white';
                    swingOutBtn.style.borderColor = '#4CAF50';
                    swingInBtn.style.background = 'white';
                    swingInBtn.style.color = '#333';
                    swingInBtn.style.borderColor = '#ddd';
                }
            } else {
                heightFields.style.display = 'none';
            }
            
            const modal = document.getElementById('positionModal');
            modal.style.display = 'flex';
            
            // Focus and select input
            setTimeout(() => {
                posInput.focus();
                posInput.select();
            }, 100);
        }
        
        // Temporary storage for door swing changes
        let tempDoorSwing = null;
        
        function setDoorHinge(side) {
            // Update button styles
            const hingeLeftBtn = document.getElementById('hingeLeftBtn');
            const hingeRightBtn = document.getElementById('hingeRightBtn');
            
            if (side === 'left') {
                hingeLeftBtn.style.background = '#4CAF50';
                hingeLeftBtn.style.color = 'white';
                hingeLeftBtn.style.borderColor = '#4CAF50';
                hingeRightBtn.style.background = 'white';
                hingeRightBtn.style.color = '#333';
                hingeRightBtn.style.borderColor = '#ddd';
            } else {
                hingeRightBtn.style.background = '#4CAF50';
                hingeRightBtn.style.color = 'white';
                hingeRightBtn.style.borderColor = '#4CAF50';
                hingeLeftBtn.style.background = 'white';
                hingeLeftBtn.style.color = '#333';
                hingeLeftBtn.style.borderColor = '#ddd';
            }
            
            // Update the door immediately
            const room = getCurrentRoom();
            if (room && positionFeatureType === 'door' && positionFeatureIndex !== null) {
                const door = room.doors[positionFeatureIndex];
                if (door) {
                    door.hinge = side;
                    redraw2D();
                    if (state.currentView === '3d') {
                        render3D();
                    }
                }
            }
        }
        
        function setDoorSwingDirection(direction) {
            // Update button styles
            const swingInBtn = document.getElementById('swingInBtn');
            const swingOutBtn = document.getElementById('swingOutBtn');
            
            if (direction === 'in') {
                swingInBtn.style.background = '#4CAF50';
                swingInBtn.style.color = 'white';
                swingInBtn.style.borderColor = '#4CAF50';
                swingOutBtn.style.background = 'white';
                swingOutBtn.style.color = '#333';
                swingOutBtn.style.borderColor = '#ddd';
            } else {
                swingOutBtn.style.background = '#4CAF50';
                swingOutBtn.style.color = 'white';
                swingOutBtn.style.borderColor = '#4CAF50';
                swingInBtn.style.background = 'white';
                swingInBtn.style.color = '#333';
                swingInBtn.style.borderColor = '#ddd';
            }
            
            // Update the door immediately
            const room = getCurrentRoom();
            if (room && positionFeatureType === 'door' && positionFeatureIndex !== null) {
                const door = room.doors[positionFeatureIndex];
                if (door) {
                    door.swingDirection = direction;
                    redraw2D();
                    if (state.currentView === '3d') {
                        render3D();
                    }
                }
            }
        }
        
        function confirmPosition() {
            const room = getCurrentRoom();
            if (!room || positionFeatureType === null || positionFeatureIndex === null) return;
            
            const inputDistance = parseFloat(document.getElementById('positionInput').value);
            const referenceCorner = document.getElementById('positionReferenceCorner').value;
            const newWidth = parseFloat(document.getElementById('positionWidthInput').value);
            const wall = room.walls[positionWallIndex];
            const wallLength = parseFloat(wall.length);
            
            // Validate width
            if (isNaN(newWidth) || newWidth < 12 || newWidth > 120) {
                showToast(`‚ùå Width must be between 12 and 120 inches`);
                return;
            }
            
            // Get the feature
            const feature = positionFeatureType === 'door' ? room.doors[positionFeatureIndex] : room.windows[positionFeatureIndex];
            const newWidthFt = newWidth / 12; // Convert inches to feet
            
            // Convert to distance from left if measuring from right
            let edgePosition;
            if (referenceCorner === 'right') {
                edgePosition = wallLength - inputDistance - newWidthFt;
            } else {
                edgePosition = inputDistance;
            }
            
            // Validate that the entire feature fits on the wall
            if (isNaN(edgePosition) || edgePosition < 0 || (edgePosition + newWidthFt) > wallLength) {
                showToast(`‚ùå Position must allow feature to fit (0 to ${(wallLength - newWidthFt).toFixed(1)} ft)`);
                return;
            }
            
            // Update width and reference corner
            feature.width = newWidth;
            feature.referenceCorner = referenceCorner;
            
            // For doors, update height and swing
            if (positionFeatureType === 'door') {
                const newHeight = parseFloat(document.getElementById('positionHeightInput').value);
                
                if (!isNaN(newHeight) && newHeight >= 12 && newHeight <= 120) {
                    feature.height = newHeight;
                }
                
                // Save swing direction from tempDoorSwing (set by setDoorSwing function)
                if (tempDoorSwing) {
                    feature.swing = tempDoorSwing;
                } else if (!feature.swing) {
                    feature.swing = 'right'; // Default if not set
                }
                
                // Reset temp swing
                tempDoorSwing = null;
            }
            
            // For windows, update height and floor height
            if (positionFeatureType === 'window') {
                const newHeight = parseFloat(document.getElementById('positionHeightInput').value);
                const newFloorHeight = parseFloat(document.getElementById('positionFloorHeightInput').value);
                
                if (!isNaN(newHeight) && newHeight >= 12 && newHeight <= 120) {
                    feature.height = newHeight;
                }
                if (!isNaN(newFloorHeight) && newFloorHeight >= 0 && newFloorHeight <= 10) {
                    feature.heightFromFloor = newFloorHeight;
                }
            }
            
            // Store distance to LEFT EDGE (what user entered)
            feature.distanceFromLeft = edgePosition;
            
            // Calculate CENTER position for rendering (edge + half width)
            const centerPosition = edgePosition + (newWidthFt / 2);
            
            // Recalculate x, y position on wall using CENTER
            const param = centerPosition / wallLength;
            
                // Draw missing wall overlays (dashed red + end ticks) and hide wall line in missing span
                if (wall.missingWalls && wall.missingWalls.length) {
                    const dx0 = wall.end.x - wall.start.x;
                    const dy0 = wall.end.y - wall.start.y;
                    const wLenPx = Math.sqrt(dx0*dx0 + dy0*dy0);
                    if (wLenPx > 0.001) {
                        const ux0 = dx0 / wLenPx;
                        const uy0 = dy0 / wLenPx;
                        const nx0 = -uy0;
                        const ny0 = ux0;
                        const scale0 = 30; // px per ft
                        const tick = 10 / state.zoom;
                        
                        wall.missingWalls.forEach((mw) => {
                            const sPx = mw.startDist * scale0;
                            const ePx = mw.endDist * scale0;

                            // erase underlying wall (creates visible gap even if cut drawing didn't cover)
                            ctx.save();
                            ctx.strokeStyle = '#f5f5f5'; // background
                            ctx.lineWidth = (6 / state.zoom);
                            ctx.beginPath();
                            ctx.moveTo(wall.start.x + ux0*sPx, wall.start.y + uy0*sPx);
                            ctx.lineTo(wall.start.x + ux0*ePx, wall.start.y + uy0*ePx);
                            ctx.stroke();
                            ctx.restore();

                            // dashed marker
                            ctx.save();
                            ctx.setLineDash([8 / state.zoom, 6 / state.zoom]);
                            ctx.strokeStyle = '#c0392b';
                            ctx.lineWidth = (3 / state.zoom);
                            ctx.beginPath();
                            ctx.moveTo(wall.start.x + ux0*sPx, wall.start.y + uy0*sPx);
                            ctx.lineTo(wall.start.x + ux0*ePx, wall.start.y + uy0*ePx);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            // end ticks
                            ctx.beginPath();
                            const sx = wall.start.x + ux0*sPx, sy = wall.start.y + uy0*sPx;
                            const ex = wall.start.x + ux0*ePx, ey = wall.start.y + uy0*ePx;
                            ctx.moveTo(sx - nx0*tick, sy - ny0*tick);
                            ctx.lineTo(sx + nx0*tick, sy + ny0*tick);
                            ctx.moveTo(ex - nx0*tick, ey - ny0*tick);
                            ctx.lineTo(ex + nx0*tick, ey + ny0*tick);
                            ctx.stroke();
                            ctx.restore();
                        });
                    }
                }

                const dx = wall.end.x - wall.start.x;

            const dy = wall.end.y - wall.start.y;
            
            feature.x = wall.start.x + param * dx;
            feature.y = wall.start.y + param * dy;
            
            // Calculate rotation angle to match wall angle
            const angle = Math.atan2(dy, dx);
            feature.rotation = angle * 180 / Math.PI;
            
            const icon = positionFeatureType === 'door' ? 'üö™' : 'ü™ü';
            showToast(`${icon} Updated - ${newWidth}" wide at ${edgePosition.toFixed(2)} ft from left`);
            
            document.getElementById('positionModal').style.display = 'none';
            positionFeatureType = null;
            positionFeatureIndex = null;
            positionWallIndex = null;
            
            redraw2D();
            if (state.currentView === '3d') {
                render3D();
            }
            updateStats();
        }
        
        function cancelPosition() {
            document.getElementById('positionModal').style.display = 'none';
            positionFeatureType = null;
            positionFeatureIndex = null;
            positionWallIndex = null;
        }
        
        function deleteCurrentFeature() {
            const room = getCurrentRoom();
            if (!room || positionFeatureType === null || positionFeatureIndex === null) return;
            
            const icon = positionFeatureType === 'door' ? 'üö™' : 'ü™ü';
            const typeName = positionFeatureType === 'door' ? 'Door' : 'Window';
            
            // Delete the feature
            if (positionFeatureType === 'door') {
                room.doors.splice(positionFeatureIndex, 1);
            } else {
                room.windows.splice(positionFeatureIndex, 1);
            }
            
            showToast(`${icon} ${typeName} deleted`);
            
            // Close modal and reset
            document.getElementById('positionModal').style.display = 'none';
            positionFeatureType = null;
            positionFeatureIndex = null;
            positionWallIndex = null;
            
            redraw2D();
            if (state.currentView === '3d') {
                render3D();
            }
            updateStats();
        }
        
        // Handle Enter key in position modal
        document.addEventListener('DOMContentLoaded', function() {
            const positionInput = document.getElementById('positionInput');
            if (positionInput) {
                positionInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        confirmPosition();
                    } else if (e.key === 'Escape') {
                        cancelPosition();
                    }
                });
            }
            
            // Handle reference corner change for position modal
            const positionReferenceCorner = document.getElementById('positionReferenceCorner');
            if (positionReferenceCorner) {
                positionReferenceCorner.addEventListener('change', function(e) {
                    const label = document.getElementById('positionDistanceLabel');
                    if (e.target.value === 'right') {
                        label.textContent = 'Distance to Left Edge from Right (feet):';
                    } else {
                        label.textContent = 'Distance to Left Edge from Left (feet):';
                    }
                });
            }
            
            // Handle reference corner change for missing wall modal
            const missingWallReference = document.getElementById('missingWallReference');
            if (missingWallReference) {
                missingWallReference.addEventListener('change', function(e) {
                    const startLabel = document.getElementById('missingWallStartLabel');
                    const endLabel = document.getElementById('missingWallEndLabel');
                    if (e.target.value === 'right') {
                        startLabel.textContent = 'Start (ft from right corner)';
                        endLabel.textContent = 'End (ft from right corner)';
                    } else {
                        startLabel.textContent = 'Start (ft from left corner)';
                        endLabel.textContent = 'End (ft from left corner)';
                    }
                });
            }
            
            // Handle Enter key in filename modal
            const filenameInput = document.getElementById('filenameInput');
            if (filenameInput) {
                filenameInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        confirmFilename();
                    } else if (e.key === 'Escape') {
                        cancelFilename();
                    }
                });
            }
            
            // Apply Measurements button - iOS-compatible
            const applyMeasurementsBtn = document.getElementById('applyMeasurementsBtn');
            if (applyMeasurementsBtn) {
                applyMeasurementsBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    applyQuickEntry();
                });
                console.log('‚úÖ Apply Measurements button listener attached');
            }
            
            // Opening button - iOS-compatible (in addition to onclick)
            const openingBtn = document.getElementById('openingBtn');
            if (openingBtn) {
                openingBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('üß± Opening button clicked via listener');
                    selectFeature('missing-wall', e);
                });
                console.log('‚úÖ Opening button listener attached');
            }
            
            // Door button - iOS-compatible (backup for onclick)
            const doorBtn = document.getElementById('doorBtn');
            if (doorBtn) {
                doorBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('üö™ Door button clicked via listener');
                    selectFeature('door', e);
                });
                console.log('‚úÖ Door button listener attached');
            }
            
            // Window button - iOS-compatible (backup for onclick)
            const windowBtn = document.getElementById('windowBtn');
            if (windowBtn) {
                windowBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('ü™ü Window button clicked via listener');
                    selectFeature('window', e);
                });
                console.log('‚úÖ Window button listener attached');
            }
            
            // Water button - iOS-compatible (backup for onclick)
            const waterBtn = document.getElementById('waterBtn');
            if (waterBtn) {
                waterBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    selectFeature('water-damage', e);
                });
                console.log('‚úÖ Water button listener attached');
            }
            
            // Fire button - iOS-compatible (backup for onclick)
            const fireBtn = document.getElementById('fireBtn');
            if (fireBtn) {
                fireBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    selectFeature('fire-damage', e);
                });
                console.log('‚úÖ Fire button listener attached');
            }
            
            // TESTING: Using inline onclick for now
            /*
            // Feature buttons - iOS PWA needs BOTH touch AND click events
            function setupFeatureButton(buttonId, featureType, label) {
                const btn = document.getElementById(buttonId);
                if (!btn) {
                    console.error(`‚ùå Button not found: ${buttonId}`);
                    alert(`ERROR: ${buttonId} not found!`);
                    return;
                }
                
                const handler = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // SUPER VISIBLE DEBUG - Flash the background
                    document.body.style.backgroundColor = '#00FF00';
                    setTimeout(() => { document.body.style.backgroundColor = ''; }, 200);
                    
                    console.log(`üëÜ ${label} button activated`);
                    alert(`${label} button tapped!`);
                    
                    selectFeature(featureType, e);
                };
                
                // Add BOTH event types for iOS PWA
                btn.addEventListener('touchstart', handler, { passive: false });
                btn.addEventListener('click', handler);
                
                console.log(`‚úÖ ${label} button listeners attached`);
                alert(`‚úÖ ${label} button ready`);
            }
            
            // Setup all feature buttons
            setTimeout(function() {
                setupFeatureButton('doorBtn', 'door', 'Door');
                setupFeatureButton('windowBtn', 'window', 'Window');
                setupFeatureButton('openingBtn', 'missing-wall', 'Opening');
                setupFeatureButton('waterBtn', 'water-damage', 'Water');
                setupFeatureButton('fireBtn', 'fire-damage', 'Fire');
            }, 1000); // Wait 1 second to make sure DOM is ready
            */
        });

        function updateRoomList() {
            const list = document.getElementById('roomList');
            
            if (!list) {
                console.error('ERROR: Room list element not found!');
                return;
            }
            
            list.innerHTML = '';
            
            if (state.rooms.length === 0) return;
            
            state.rooms.forEach((room, i) => {
                
                const div = document.createElement('div');
                div.className = 'room-item' + (i === state.currentRoomIndex ? ' active' : '');
                div.style.display = 'flex';
                div.style.alignItems = 'center';
                div.style.gap = '5px';
                
                // Create room name text (not clickable, just display)
                const nameSpan = document.createElement('span');
                nameSpan.textContent = room.name;
                nameSpan.style.cssText = 'flex: 1; padding: 8px;';
                
                // Create EDIT NAME button - very obvious
                const editNameBtn = document.createElement('button');
                editNameBtn.textContent = '‚úèÔ∏è';
                editNameBtn.style.cssText = 'padding: 6px 10px; font-size: 14px; background: #FFA500; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;';
                editNameBtn.title = 'Edit room name';
                editNameBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    console.log('===== EDIT NAME BUTTON CLICKED =====');
                    console.log('Room index:', i);
                    console.log('Current name:', room.name);
                    showEditNameModal(i);
                });
                
                // Create edit measurements button
                const editMeasureBtn = document.createElement('button');
                editMeasureBtn.textContent = 'üìè';
                editMeasureBtn.style.cssText = 'padding: 6px 10px; font-size: 14px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;';
                editMeasureBtn.title = 'Edit measurements';
                editMeasureBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    editRoomMeasurements(i);
                });
                
                // Create delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '√ó';
                deleteBtn.style.cssText = 'padding: 6px 10px; font-size: 18px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;';
                deleteBtn.title = 'Delete room';
                deleteBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    deleteRoom(i);
                });
                
                div.appendChild(nameSpan);
                div.appendChild(editNameBtn);
                div.appendChild(editMeasureBtn);
                div.appendChild(deleteBtn);
                
                // Click on the row to switch rooms
                div.addEventListener('click', function() {
                    console.log('Switching to room', i);
                    switchRoom(i);
                });
                
                list.appendChild(div);
            });
        }

        function editRoomName(index) {
            // This function now calls the modal version
            showEditNameModal(index);
        }
        
        function cutWallPortion(index) {
            const room = state.rooms[index];
            
            // Switch to this room
            state.currentRoomIndex = index;
            updateRoomList();
            
            // Store room index for modal
            cutWallRoomIndex = index;
            editingCut = null;
            document.getElementById('cutWallModalTitle').textContent = '‚úÇÔ∏è Cut Portion of Wall';
            document.getElementById('cutWallDeleteBtn').style.display = 'none';
            document.getElementById('cutWallConfirmBtn').textContent = '‚úÇÔ∏è Cut Wall';
// Update modal with room name
            document.getElementById('cutWallRoomName').textContent = room.name;
            
            // Populate wall dropdown
            const select = document.getElementById('cutWallSelect');
            select.innerHTML = '<option value="">Choose a wall...</option>';
            room.walls.forEach((wall, idx) => {
                const option = document.createElement('option');
                option.value = idx;
                option.textContent = `${wall.name} (${wall.length} ft)`;
                select.appendChild(option);
            });
            
            // Show modal
            const modal = document.getElementById('cutWallModal');
            modal.style.display = 'block';
            
            // Focus select
            setTimeout(() => {
                select.focus();
            }, 100);
        }

        // Find if a click is on a wall cut (gap) in the current room.
        function findClickedCut(room, x, y) {
            if (!room || !room.walls) return null;
            const SCALE = 30; // px per ft
            for (let wallIdx = 0; wallIdx < room.walls.length; wallIdx++) {
                const wall = room.walls[wallIdx];
                if (!wall.cuts || wall.cuts.length === 0) continue;

                // Near the wall line?
                const dist = distanceToLineSegment(x, y, wall.start.x, wall.start.y, wall.end.x, wall.end.y);
                if (dist > 22) continue; // must click close to wall

                // Project click onto wall to get distance from start (feet)
                const A = x - wall.start.x;
                const B = y - wall.start.y;
                const C = wall.end.x - wall.start.x;
                const D = wall.end.y - wall.start.y;
                const lenSq = C * C + D * D;
                if (lenSq === 0) continue;

                let param = (A * C + B * D) / lenSq;
                param = Math.max(0, Math.min(1, param));
                const projX = wall.start.x + param * C;
                const projY = wall.start.y + param * D;

                const distFromStartPx = Math.sqrt((projX - wall.start.x) ** 2 + (projY - wall.start.y) ** 2);
                const distFromStartFt = distFromStartPx / SCALE;

                for (let cutIdx = 0; cutIdx < wall.cuts.length; cutIdx++) {
                    const cut = wall.cuts[cutIdx];
                    if (distFromStartFt >= cut.startDist - 0.05 && distFromStartFt <= cut.endDist + 0.05) {
                        return { wallIdx, cutIdx };
                    }
                }
            }
            return null;
        }

        function showCutWallEditModal(roomIndex, wallIdx, cutIdx) {
            const room = state.rooms[roomIndex];
            if (!room) return;
            const wall = room.walls[wallIdx];
            if (!wall || !wall.cuts || !wall.cuts[cutIdx]) return;

            // Switch to this room (keep behavior consistent with cutting)
            state.currentRoomIndex = roomIndex;
            updateRoomList();

            cutWallRoomIndex = roomIndex;
            editingCut = { roomIndex, wallIdx, cutIdx };

            document.getElementById('cutWallModalTitle').textContent = '‚úÇÔ∏è Edit Wall Cut';
            document.getElementById('cutWallRoomName').textContent = room.name;

            // Populate walls
            const select = document.getElementById('cutWallSelect');
            select.innerHTML = '<option value="">Choose a wall...</option>';
            room.walls.forEach((w, idx) => {
                const option = document.createElement('option');
                option.value = idx;
                option.textContent = `${w.name} (${w.length} ft)`;
                select.appendChild(option);
            });
            select.value = String(wallIdx);

            // Prefill distances
            const cut = wall.cuts[cutIdx];
            document.getElementById('cutWallStart').value = cut.startDist;
            document.getElementById('cutWallEnd').value = cut.endDist;

            // Show modal + buttons
            document.getElementById('cutWallDeleteBtn').style.display = 'inline-block';
            document.getElementById('cutWallConfirmBtn').textContent = '‚úÖ Update Cut';

            const modal = document.getElementById('cutWallModal');
            modal.style.display = 'block';

            setTimeout(() => document.getElementById('cutWallStart').focus(), 50);
        }

        function deleteCurrentCutWall() {
            if (!editingCut) return;
            const { roomIndex, wallIdx, cutIdx } = editingCut;
            const room = state.rooms[roomIndex];
            if (!room) return;
            const wall = room.walls[wallIdx];
            if (!wall || !wall.cuts || !wall.cuts[cutIdx]) return;

            saveStateForUndo();
            wall.cuts.splice(cutIdx, 1);
            if (wall.cuts.length === 0) delete wall.cuts;

            document.getElementById('cutWallModal').style.display = 'none';
            editingCut = null;
            cutWallRoomIndex = null;

            redraw2D();
            if (state.currentView === '3d') render3D();
            updateStats();
            showToast('üóëÔ∏è Cut removed');
        }

        
        
        // =========================
        // Missing Wall (Xactimate-style) - add/edit/delete
        // =========================
        let editingMissing = null;
        let missingWallRoomIndex = null;

        function getWallOpenings(wall) {
            const openings = [];
            if (wall.cuts && wall.cuts.length) {
                wall.cuts.forEach((c, idx) => openings.push({ 
                    type: 'cut', 
                    idx, 
                    startDist: Number(c.startDist), 
                    endDist: Number(c.endDist),
                    height: Number(c.height) || 3,
                    floorDistance: Number(c.floorDistance) || 0
                }));
            }
            if (wall.missingWalls && wall.missingWalls.length) {
                wall.missingWalls.forEach((mw, idx) => openings.push({ 
                    type: 'missing', 
                    idx, 
                    startDist: Number(mw.startDist), 
                    endDist: Number(mw.endDist),
                    height: Number(mw.height) || 3,
                    floorDistance: Number(mw.floorDistance) || 0
                }));
            }
            return openings.filter(o => isFinite(o.startDist) && isFinite(o.endDist) && o.endDist > o.startDist).sort((a,b)=>a.startDist-b.startDist);
        }

        function showMissingWallModal() {
            const room = getCurrentRoom();
            if (!room || !room.walls || room.walls.length === 0) { showToast('‚ùå Create floor plan first'); return; }

            missingWallRoomIndex = state.currentRoomIndex;
            editingMissing = null;

            document.getElementById('missingWallModalTitle').textContent = 'üß± Add Missing Wall';
            document.getElementById('missingWallRoomName').textContent = room.name;

            const select = document.getElementById('missingWallSelect');
            select.innerHTML = '';
            room.walls.forEach((w, idx) => {
                const opt = document.createElement('option');
                opt.value = String(idx);
                opt.textContent = `${w.name} (${w.length} ft)`;
                select.appendChild(opt);
            });

            // Preselect hovered/selected wall if available
            if (state.selectedWall !== null && state.selectedWall !== undefined) select.value = String(state.selectedWall);

            document.getElementById('missingWallStart').value = 0;
            document.getElementById('missingWallEnd').value = 1;
            document.getElementById('missingWallHeight').value = 3;
            document.getElementById('missingWallFloorDist').value = 0;
            document.getElementById('missingWallReference').value = 'left';
            document.getElementById('missingWallStartLabel').textContent = 'Start (ft from left corner)';
            document.getElementById('missingWallEndLabel').textContent = 'End (ft from left corner)';

            document.getElementById('missingWallDeleteBtn').style.display = 'none';
            document.getElementById('missingWallConfirmBtn').textContent = '‚úÖ Save';

            document.getElementById('missingWallModal').style.display = 'flex';
            setTimeout(() => document.getElementById('missingWallStart').focus(), 50);
        }

        function showMissingWallEditModal(roomIndex, wallIdx, missIdx) {
            const room = state.rooms[roomIndex];
            if (!room) return;
            const wall = room.walls[wallIdx];
            if (!wall || !wall.missingWalls || !wall.missingWalls[missIdx]) return;

            state.currentRoomIndex = roomIndex;
            updateRoomList();

            missingWallRoomIndex = roomIndex;
            editingMissing = { roomIndex, wallIdx, missIdx };

            document.getElementById('missingWallModalTitle').textContent = 'üß± Edit Missing Wall';
            document.getElementById('missingWallRoomName').textContent = room.name;

            const select = document.getElementById('missingWallSelect');
            select.innerHTML = '';
            room.walls.forEach((w, idx) => {
                const opt = document.createElement('option');
                opt.value = String(idx);
                opt.textContent = `${w.name} (${w.length} ft)`;
                select.appendChild(opt);
            });
            select.value = String(wallIdx);

            const mw = wall.missingWalls[missIdx];
            const referenceCorner = mw.referenceCorner || 'left';
            const wallLength = parseFloat(wall.length);
            
            document.getElementById('missingWallReference').value = referenceCorner;
            
            if (referenceCorner === 'right') {
                // Convert from left-based storage to right-based display
                const startFromRight = wallLength - mw.endDist;
                const endFromRight = wallLength - mw.startDist;
                document.getElementById('missingWallStart').value = startFromRight;
                document.getElementById('missingWallEnd').value = endFromRight;
                document.getElementById('missingWallStartLabel').textContent = 'Start (ft from right corner)';
                document.getElementById('missingWallEndLabel').textContent = 'End (ft from right corner)';
            } else {
                document.getElementById('missingWallStart').value = mw.startDist;
                document.getElementById('missingWallEnd').value = mw.endDist;
                document.getElementById('missingWallStartLabel').textContent = 'Start (ft from left corner)';
                document.getElementById('missingWallEndLabel').textContent = 'End (ft from left corner)';
            }
            
            document.getElementById('missingWallHeight').value = mw.height || 3;
            document.getElementById('missingWallFloorDist').value = mw.floorDistance || 0;

            document.getElementById('missingWallDeleteBtn').style.display = 'inline-block';
            document.getElementById('missingWallConfirmBtn').textContent = '‚úÖ Update';

            document.getElementById('missingWallModal').style.display = 'flex';
            setTimeout(() => document.getElementById('missingWallStart').focus(), 50);
        }

        function cancelMissingWall() {
            document.getElementById('missingWallModal').style.display = 'none';
            editingMissing = null;
            missingWallRoomIndex = null;
        }

        function deleteCurrentMissingWall() {
            if (!editingMissing) return;
            const { roomIndex, wallIdx, missIdx } = editingMissing;
            const room = state.rooms[roomIndex];
            if (!room) return;
            const wall = room.walls[wallIdx];
            if (!wall || !wall.missingWalls || !wall.missingWalls[missIdx]) return;

            saveStateForUndo();
            wall.missingWalls.splice(missIdx, 1);
            if (wall.missingWalls.length === 0) delete wall.missingWalls;

            cancelMissingWall();
            redraw2D();
            if (state.currentView === '3d') render3D();
            updateStats();
            showToast('üóëÔ∏è Missing wall removed');
        }

        function confirmMissingWall() {
            if (missingWallRoomIndex === null) { showToast('‚ùå No room selected'); return; }
            const room = state.rooms[missingWallRoomIndex];
            if (!room) return;

            const wallIdx = parseInt(document.getElementById('missingWallSelect').value, 10);
            const inputStart = parseFloat(document.getElementById('missingWallStart').value);
            const inputEnd = parseFloat(document.getElementById('missingWallEnd').value);
            const referenceCorner = document.getElementById('missingWallReference').value;
            const height = parseFloat(document.getElementById('missingWallHeight').value);
            const floorDistance = parseFloat(document.getElementById('missingWallFloorDist').value);

            if (!isFinite(wallIdx) || wallIdx < 0 || wallIdx >= room.walls.length) { showToast('‚ùå Select a wall'); return; }
            if (!isFinite(inputStart) || !isFinite(inputEnd) || inputStart < 0 || inputEnd <= inputStart) { showToast('‚ùå Invalid dimensions'); return; }
            if (!isFinite(height) || height <= 0) { showToast('‚ùå Invalid height'); return; }
            if (!isFinite(floorDistance) || floorDistance < 0) { showToast('‚ùå Invalid floor distance'); return; }

            const wall = room.walls[wallIdx];
            const wallLen = parseFloat(wall.length);
            
            // Convert to left-based storage if measuring from right
            let startDist, endDist;
            if (referenceCorner === 'right') {
                startDist = wallLen - inputEnd;
                endDist = wallLen - inputStart;
            } else {
                startDist = inputStart;
                endDist = inputEnd;
            }
            
            if (endDist > wallLen + 1e-6) { showToast(`‚ùå End exceeds wall length (${wallLen} ft)`); return; }

            saveStateForUndo();

            if (editingMissing && editingMissing.roomIndex === missingWallRoomIndex) {
                const { wallIdx: oldWallIdx, missIdx } = editingMissing;
                const oldWall = room.walls[oldWallIdx];
                const item = oldWall.missingWalls[missIdx];
                if (oldWallIdx !== wallIdx) {
                    oldWall.missingWalls.splice(missIdx, 1);
                    if (oldWall.missingWalls.length === 0) delete oldWall.missingWalls;
                    if (!wall.missingWalls) wall.missingWalls = [];
                    wall.missingWalls.push({ startDist, endDist, height, floorDistance, referenceCorner, name: item.name || `Missing ${Date.now()}` });
                } else {
                    item.startDist = startDist;
                    item.endDist = endDist;
                    item.height = height;
                    item.floorDistance = floorDistance;
                    item.referenceCorner = referenceCorner;
                }
            } else {
                if (!wall.missingWalls) wall.missingWalls = [];
                wall.missingWalls.push({ startDist, endDist, height, floorDistance, referenceCorner, name: `Missing ${wall.missingWalls.length + 1}` });
            }

            cancelMissingWall();
            redraw2D();
            if (state.currentView === '3d') render3D();
            updateStats();
            showToast('üß± Missing wall saved');
        }

        function findMissingAtPoint(room, x, y) {
            if (!room || !room.walls) return null;
            const SCALE = 30; // px per ft
            for (let wallIdx = 0; wallIdx < room.walls.length; wallIdx++) {
                const wall = room.walls[wallIdx];
                if (!wall.missingWalls || wall.missingWalls.length === 0) continue;

                const dist = distanceToLineSegment(x, y, wall.start.x, wall.start.y, wall.end.x, wall.end.y);
                if (dist > 22) continue;

                const A = x - wall.start.x;
                const B = y - wall.start.y;
                const C = wall.end.x - wall.start.x;
                const D = wall.end.y - wall.start.y;
                const lenSq = C*C + D*D;
                if (lenSq === 0) continue;
                let param = (A*C + B*D) / lenSq;
                param = Math.max(0, Math.min(1, param));
                const projX = wall.start.x + param * C;
                const projY = wall.start.y + param * D;
                const distFromStartPx = Math.sqrt((projX - wall.start.x)**2 + (projY - wall.start.y)**2);
                const distFromStartFt = distFromStartPx / SCALE;

                for (let missIdx=0; missIdx<wall.missingWalls.length; missIdx++) {
                    const mw = wall.missingWalls[missIdx];
                    if (distFromStartFt >= mw.startDist - 0.05 && distFromStartFt <= mw.endDist + 0.05) {
                        return { wallIdx, missIdx };
                    }
                }
            }
            return null;
        }

function confirmCutWall() {
            console.log('=== confirmCutWall called ===');
            console.log('cutWallRoomIndex:', cutWallRoomIndex);
            
            if (cutWallRoomIndex === null) {
                console.log('ERROR: cutWallRoomIndex is null');
                return;
            }
            
            const room = state.rooms[cutWallRoomIndex];
            console.log('Room:', room.name);
            
            const wallIdx = parseInt(document.getElementById('cutWallSelect').value);
            const startDist = parseFloat(document.getElementById('cutWallStart').value);
            const endDist = parseFloat(document.getElementById('cutWallEnd').value);
            
            console.log('Wall Index:', wallIdx);
            console.log('Start Distance:', startDist);
            console.log('End Distance:', endDist);
            
            if (isNaN(wallIdx) || wallIdx < 0 || wallIdx >= room.walls.length) {
                console.log('ERROR: Invalid wall index');
                showToast('‚ùå Please select a wall');
                return;
            }
            
            if (isNaN(startDist) || isNaN(endDist) || startDist < 0 || endDist <= startDist) {
                console.log('ERROR: Invalid dimensions');
                showToast('‚ùå Invalid dimensions (End must be greater than Start)');
                return;
            }
            
            const wall = room.walls[wallIdx];
            const wallLength = parseFloat(wall.length);
            
            console.log('Wall:', wall.name, 'Length:', wallLength);
            
            if (endDist > wallLength) {
                console.log('ERROR: End distance exceeds wall length');
                showToast(`‚ùå End distance exceeds wall length (${wallLength} ft)`);
                return;
            }
            
            const cutLength = endDist - startDist;
            console.log('Cut Length:', cutLength);
            
            // Save state for undo
            saveStateForUndo();
            
            // Create or update cut
            if (editingCut && editingCut.roomIndex === cutWallRoomIndex) {
                // Updating an existing cut
                const { wallIdx: oldWallIdx, cutIdx } = editingCut;
                const oldWall = room.walls[oldWallIdx];
                if (oldWall && oldWall.cuts && oldWall.cuts[cutIdx]) {
                    // If user changed wall selection, move cut to new wall
                    if (oldWallIdx !== wallIdx) {
                        // Remove from old
                        const moved = oldWall.cuts.splice(cutIdx, 1)[0];
                        if (oldWall.cuts.length === 0) delete oldWall.cuts;

                        // Add to new
                        if (!wall.cuts) wall.cuts = [];
                        moved.startDist = startDist;
                        moved.endDist = endDist;
                        wall.cuts.push(moved);
                    } else {
                        // Update in place
                        oldWall.cuts[cutIdx].startDist = startDist;
                        oldWall.cuts[cutIdx].endDist = endDist;
                    }
                }
            } else {
                // Adding a new cut
                if (!wall.cuts) wall.cuts = [];
                wall.cuts.push({
                    startDist: startDist,
                    endDist: endDist,
                    name: `Cut ${wall.cuts.length + 1}`
                });
            }

            
            console.log('Added cut to wall:', wall.cuts);
            
            showToast(`‚úÇÔ∏è Cut ${cutLength.toFixed(1)} ft from ${wall.name} (${startDist.toFixed(1)}-${endDist.toFixed(1)} ft)`);
            
            // Close modal
            document.getElementById('cutWallModal').style.display = 'none';
            cutWallRoomIndex = null;
            editingCut = null;
            document.getElementById('cutWallDeleteBtn').style.display = 'none';
            document.getElementById('cutWallConfirmBtn').textContent = '‚úÇÔ∏è Cut Wall';
            document.getElementById('cutWallModalTitle').textContent = '‚úÇÔ∏è Cut Portion of Wall';
            
            console.log('Redrawing...');
            redraw2D();
            if (state.currentView === '3d') {
                render3D();
            }
            updateStats();
            console.log('=== confirmCutWall complete ===');
        }
        
        function cancelCutWall() {
            document.getElementById('cutWallModal').style.display = 'none';
            cutWallRoomIndex = null;
            editingCut = null;
            document.getElementById('cutWallDeleteBtn').style.display = 'none';
            document.getElementById('cutWallConfirmBtn').textContent = '‚úÇÔ∏è Cut Wall';
            document.getElementById('cutWallModalTitle').textContent = '‚úÇÔ∏è Cut Portion of Wall';
        }
        
        function recalculateFloorPlan(room) {
            // Recalculate floor points based on walls
            const points = [];
            let x = 0;
            let y = 0;
            let angle = 0;
            
            room.walls.forEach((wall, idx) => {
                const len = parseFloat(wall.length) * 30; // Convert to pixels
                
                // Set wall start and end points
                wall.start = {x, y};
                
                // Calculate end point
                const endX = x + len * Math.cos(angle);
                const endY = y + len * Math.sin(angle);
                wall.end = {x: endX, y: endY};
                
                // Add point
                points.push({x, y});
                
                // Move to next position
                x = endX;
                y = endY;
                
                // Turn 90 degrees for next wall (interior angle)
                angle += Math.PI / 2;
            });
            
            room.floorPoints = points;
        }

        function editRoomMeasurements(index) {
            const room = state.rooms[index];
            const wasCurrentRoom = index === state.currentRoomIndex;
            
            // Switch to this room
            state.currentRoomIndex = index;
            updateRoomList();
            
            // Pre-populate the Quick Entry fields with current measurements
            if (room.walls.length > 0) {
                // Set wall count
                const wallCount = room.walls.length;
                document.getElementById('wallCount').value = wallCount;
                
                // Generate input fields
                generateWallInputs();
                
                // Wait a moment for fields to be created, then populate them
                setTimeout(() => {
                    room.walls.forEach((wall, i) => {
                        const input = document.getElementById(`wall${i+1}Length`);
                        if (input) {
                            input.value = wall.length;
                        }
                    });
                }, 50);
                
                // Populate ceiling height
                if (room.ceilingHeight) {
                    document.getElementById('ceilingHeight').value = room.ceilingHeight;
                }
                
                // Populate wall thickness
                if (room.wallThickness) {
                    document.getElementById('wallThickness').value = room.wallThickness;
                }
                
                showToast('üìè Adjust measurements and click "Apply Measurements"');
            } else {
                showToast('üìè Enter measurements in Quick Entry panel and click "Apply Measurements"');
            }
            
            // Room stays visible - no clearing!
            redraw2D();
        }

        function getCurrentRoom() {
            return state.rooms[state.currentRoomIndex] || null;
        }

        function switch2D() {
            state.currentView = '2d';
            document.getElementById('canvasArea').classList.remove('view-3d');
            document.querySelectorAll('.view-btn')[0].classList.add('active');
            document.querySelectorAll('.view-btn')[1].classList.remove('active');
        }

        function switch3D() {
            console.log('=== Switching to 3D view ===');
            console.log('Current rooms:', state.rooms.length);
            
            state.currentView = '3d';
            document.getElementById('canvasArea').classList.add('view-3d');
            document.querySelectorAll('.view-btn')[0].classList.remove('active');
            document.querySelectorAll('.view-btn')[1].classList.add('active');
            
            // CALCULATE CENTER IMMEDIATELY before rendering
            const totalRooms = state.rooms.filter(r => r.floorPoints && r.floorPoints.length >= 3).length;
            
            if (totalRooms === 1) {
                const room = state.rooms.find(r => r.floorPoints && r.floorPoints.length >= 3);
                if (room) {
                    const idx = state.rooms.indexOf(room);
                    const roomSpacing = 30;
                    
                    // Use EXACT same offset logic as rendering
                    const offsetX = (room.positionX !== undefined && room.positionX !== null) ? room.positionX : (idx * roomSpacing);
                    const offsetZ = (room.positionZ !== undefined && room.positionZ !== null) ? room.positionZ : 0;
                    
                    // Calculate room center
                    const centerXpx = room.floorPoints.reduce((sum, p) => sum + p.x, 0) / room.floorPoints.length;
                    const centerZpx = room.floorPoints.reduce((sum, p) => sum + p.y, 0) / room.floorPoints.length;
                    
                    const centerX = -(centerXpx / 30 + offsetX);
                    const centerZ = -(centerZpx / 30 + offsetZ);
                    const centerY = room.ceilingHeight * 0.3048 / 2;
                    
                    console.log('üéØ PRE-RENDER CENTER (1 room):', centerX.toFixed(1), centerY.toFixed(1), centerZ.toFixed(1));
                    
                    // SET TARGET IMMEDIATELY
                    if (window.setOrbitTarget) {
                        window.setOrbitTarget(centerX, centerY, centerZ);
                    }
                    
                    // RESET CAMERA ANGLES IMMEDIATELY
                    if (window.resetCameraView) {
                        window.resetCameraView();
                    }
                }
            } else if (totalRooms > 1) {
                // Calculate ACTUAL bounding box of all rooms
                let minX = Infinity, maxX = -Infinity;
                let minZ = Infinity, maxZ = -Infinity;
                let totalHeight = 0;
                
                state.rooms.forEach((room, idx) => {
                    if (room.floorPoints.length < 3) return;
                    
                    const roomSpacing = 30;
                    const offsetX = (room.positionX !== undefined && room.positionX !== null) ? room.positionX : (idx * roomSpacing);
                    const offsetZ = (room.positionZ !== undefined && room.positionZ !== null) ? room.positionZ : 0;
                    
                    room.floorPoints.forEach(p => {
                        const x = -(p.x / 30 + offsetX);
                        const z = -(p.y / 30 + offsetZ);
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minZ = Math.min(minZ, z);
                        maxZ = Math.max(maxZ, z);
                    });
                    
                    totalHeight += room.ceilingHeight;
                });
                
                const centerX = (minX + maxX) / 2;
                const centerZ = (minZ + maxZ) / 2;
                const avgHeight = totalHeight / totalRooms;
                const centerY = avgHeight * 0.3048 / 2;
                
                console.log('üéØ PRE-RENDER CENTER (multi-room):');
                console.log('  Bounds: X[', minX.toFixed(1), 'to', maxX.toFixed(1), '], Z[', minZ.toFixed(1), 'to', maxZ.toFixed(1), ']');
                console.log('  Center:', centerX.toFixed(1), centerY.toFixed(1), centerZ.toFixed(1));
                
                if (window.setOrbitTarget) {
                    window.setOrbitTarget(centerX, centerY, centerZ);
                }
                if (window.resetCameraView) {
                    window.resetCameraView();
                }
            }
            
            console.log('Calling render3D()...');
            render3D();
            console.log('=== 3D view switch complete ===');
        }
        
        function resetCamera() {
            if (state.currentView !== '3d') {
                showToast('‚ö†Ô∏è Switch to 3D view first');
                return;
            }
            
            // Reset camera by recalculating orbit target
            const totalRooms = state.rooms.filter(r => r.floorPoints && r.floorPoints.length >= 3).length;
            const roomSpacing = 30;
            
            if (totalRooms > 1) {
                const totalWidth = (totalRooms - 1) * roomSpacing;
                const centerX = totalWidth / 2;
                if (window.setOrbitTarget) {
                    window.setOrbitTarget(centerX, 4, 0);
                }
            } else if (totalRooms === 1) {
                const room = state.rooms.find(r => r.floorPoints && r.floorPoints.length >= 3);
                if (room) {
                    const centerX = -(room.floorPoints.reduce((sum, p) => sum + p.x, 0) / room.floorPoints.length / 30);
                    const centerZ = -room.floorPoints.reduce((sum, p) => sum + p.y, 0) / room.floorPoints.length / 30;
                    const centerY = room.ceilingHeight * 0.3048 / 2;
                    
                    if (window.setOrbitTarget) {
                        window.setOrbitTarget(centerX, centerY, centerZ);
                    }
                }
            }
            
            // Re-render
            renderer.render(scene, camera);
            showToast('üîÑ Camera reset to default view');
        }

        function generateWallInputs() {
            const count = parseInt(document.getElementById('wallCount').value);
            const container = document.getElementById('wallInputs');
            container.innerHTML = '';
            
            // Clear previous turn selections
            window.wallTurns = {};
            
            for (let i = 1; i <= count; i++) {
                const div = document.createElement('div');
                div.className = 'wall-entry';
                div.style.marginBottom = '15px';
                
                // Wall length input
                let html = `
                    <label style="display: block; margin-bottom: 5px; font-weight: 600;">Wall ${i} (ft)</label>
                    <input type="number" id="wall${i}Length" placeholder="0.0" step="0.1" 
                           oninput="livePreview()"
                           style="width: 100%; padding: 8px; margin-bottom: 8px; font-size: 14px; border: 2px solid #ddd; border-radius: 4px;">
                `;
                
                // Add turn direction buttons for all walls except the last one
                if (i < count) {
                    html += `
                        <div style="margin-top: 12px; padding: 15px; background: #f0f0f0; border-radius: 10px; border: 3px solid #999;">
                            <label style="display: block; font-size: 15px; font-weight: 700; color: #333; margin-bottom: 12px; text-align: center; text-transform: uppercase;">
                                ‚¨áÔ∏è After Wall ${i}, turn which way? ‚¨áÔ∏è
                            </label>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                <button type="button" class="turn-btn" id="wall${i}TurnLeft" 
                                        onclick="selectTurn(${i}, 'left')"
                                        style="padding: 25px 15px; font-size: 18px; font-weight: 900; border: 4px solid #ddd; border-radius: 10px; background: white; cursor: pointer; transition: all 0.3s; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                                    <div style="font-size: 40px; margin-bottom: 8px;">‚¨ÖÔ∏è</div>
                                    <div style="font-size: 20px;">LEFT</div>
                                    <div style="font-size: 11px; margin-top: 5px; opacity: 0.7;">Counter-clockwise</div>
                                </button>
                                <button type="button" class="turn-btn" id="wall${i}TurnRight" 
                                        onclick="selectTurn(${i}, 'right')"
                                        style="padding: 25px 15px; font-size: 18px; font-weight: 900; border: 4px solid #4CAF50; border-radius: 10px; background: #4CAF50; color: white; cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 15px rgba(76, 175, 80, 0.5);">
                                    <div style="font-size: 40px; margin-bottom: 8px;">‚û°Ô∏è</div>
                                    <div style="font-size: 20px;">RIGHT</div>
                                    <div style="font-size: 11px; margin-top: 5px; opacity: 0.9;">Clockwise (DEFAULT)</div>
                                </button>
                            </div>
                            <div id="wall${i}TurnStatus" style="text-align: center; margin-top: 12px; padding: 8px; font-size: 14px; font-weight: 700; border-radius: 5px; background: #4CAF50; color: white;">
                                ‚úì Will turn RIGHT (default)
                            </div>
                        </div>
                    `;
                }
                
                div.innerHTML = html;
                container.appendChild(div);
            }
        }
        
        function selectTurn(wallNum, direction) {
            console.log(`selectTurn called: wall ${wallNum}, direction ${direction}`);
            
            const leftBtn = document.getElementById(`wall${wallNum}TurnLeft`);
            const rightBtn = document.getElementById(`wall${wallNum}TurnRight`);
            const statusDiv = document.getElementById(`wall${wallNum}TurnStatus`);
            
            if (direction === 'left') {
                // LEFT button selected - BRIGHT ORANGE!
                leftBtn.style.background = '#FF5722';
                leftBtn.style.color = 'white';
                leftBtn.style.borderColor = '#FF5722';
                leftBtn.style.boxShadow = '0 6px 20px rgba(255, 87, 34, 0.6)';
                leftBtn.style.transform = 'scale(1.05)';
                
                // RIGHT button unselected
                rightBtn.style.background = 'white';
                rightBtn.style.color = '#333';
                rightBtn.style.borderColor = '#ddd';
                rightBtn.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
                rightBtn.style.transform = 'scale(1)';
                
                // Update status box
                if (statusDiv) {
                    statusDiv.style.background = '#FF5722';
                    statusDiv.innerHTML = '‚¨ÖÔ∏è Will turn LEFT!';
                }
                
                showToast(`üîÑ Wall ${wallNum} ‚Üí Will turn LEFT ‚¨ÖÔ∏è`, 'warning');
            } else {
                // RIGHT button selected - BRIGHT GREEN!
                rightBtn.style.background = '#4CAF50';
                rightBtn.style.color = 'white';
                rightBtn.style.borderColor = '#4CAF50';
                rightBtn.style.boxShadow = '0 6px 20px rgba(76, 175, 80, 0.6)';
                rightBtn.style.transform = 'scale(1.05)';
                
                // LEFT button unselected
                leftBtn.style.background = 'white';
                leftBtn.style.color = '#333';
                leftBtn.style.borderColor = '#ddd';
                leftBtn.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
                leftBtn.style.transform = 'scale(1)';
                
                // Update status box
                if (statusDiv) {
                    statusDiv.style.background = '#4CAF50';
                    statusDiv.innerHTML = '‚û°Ô∏è Will turn RIGHT';
                }
                
                showToast(`‚û°Ô∏è Wall ${wallNum} ‚Üí Will turn RIGHT`, 'success');
            }
            
            // Store the direction
            if (!window.wallTurns) window.wallTurns = {};
            window.wallTurns[wallNum] = direction;
            console.log('window.wallTurns:', window.wallTurns);
            
            // Update live preview
            livePreview();
        }

        function livePreview() {
            // Safety checks
            if (!window.canvas2D) return;
            
            const wallCountElem = document.getElementById('wallCount');
            if (!wallCountElem) return;
            
            const wallCount = parseInt(wallCountElem.value);
            if (!wallCount || wallCount < 3) return;
            
            // Get wall lengths
            const wallLengths = [];
            for (let i = 1; i <= wallCount; i++) {
                const input = document.getElementById(`wall${i}Length`);
                const val = input ? parseFloat(input.value) : 0;
                wallLengths.push(val || 0);
            }
            
            // Check if any values entered
            const hasValues = wallLengths.some(len => len > 0);
            if (!hasValues) return;
            
            // Get turns (default to right)
            const wallTurns = [];
            for (let i = 1; i < wallCount; i++) {
                const storedTurn = window.wallTurns && window.wallTurns[i] ? window.wallTurns[i] : 'right';
                wallTurns.push(storedTurn);
                console.log(`[PREVIEW] Wall ${i} turn: ${storedTurn} (from window.wallTurns[${i}])`);
            }
            
            console.log('[PREVIEW] All turns:', wallTurns);
            console.log('[PREVIEW] window.wallTurns:', window.wallTurns);
            
            try {
                // Get current room to restore after preview
                const currentRoom = getCurrentRoom();
                
                // Build preview shape
                const cx = canvas2D.width / 2;
                const cy = canvas2D.height / 2;
                const scale = 30;
                
                const points = [];
                let x = cx - 100;
                let y = cy - 100;
                let direction = 0;
                
                points.push({ x, y });
                
                // Build walls
                for (let i = 0; i < wallLengths.length - 1; i++) {
                    const length = wallLengths[i] * scale;
                    
                    const dirName = ['RIGHT','DOWN','LEFT','UP'][direction % 4];
                    console.log(`[PREVIEW] Wall ${i+1}: Going ${dirName}, length ${wallLengths[i]}ft`);
                    
                    // Move in current direction
                    switch(direction % 4) {
                        case 0: x += length; break;
                        case 1: y += length; break;
                        case 2: x -= length; break;
                        case 3: y -= length; break;
                    }
                    
                    points.push({ x, y });
                    
                    // Turn
                    const turnType = wallTurns[i];
                    console.log(`[PREVIEW] After Wall ${i+1}, turning: ${turnType}`);
                    
                    if (wallTurns[i] === 'right') {
                        direction++;
                        console.log(`[PREVIEW] Turned right: direction ${direction-1} -> ${direction}`);
                    } else if (wallTurns[i] === 'left') {
                        direction--;
                        console.log(`[PREVIEW] Turned LEFT: direction ${direction+1} -> ${direction}`);
                    }
                    
                    direction = ((direction % 4) + 4) % 4;
                    console.log(`[PREVIEW] New direction: ${direction} (${['RIGHT','DOWN','LEFT','UP'][direction]})`);
                }
                
                // Draw
                redraw2D();
                
                const ctx = canvas2D.getContext('2d');
                ctx.save();
                
                // Preview shape
                ctx.strokeStyle = '#2196F3';
                ctx.lineWidth = 4;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                
                for (let i = 0; i < points.length; i++) {
                    if (i === 0) ctx.moveTo(points[i].x, points[i].y);
                    else ctx.lineTo(points[i].x, points[i].y);
                }
                
                // Close if last wall has value
                if (wallLengths[wallLengths.length - 1] > 0) {
                    ctx.lineTo(points[0].x, points[0].y);
                }
                
                ctx.stroke();
                
                // Draw corner dots
                ctx.fillStyle = '#2196F3';
                points.forEach(pt => {
                    ctx.beginPath();
                    ctx.arc(pt.x, pt.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Label walls
                ctx.font = 'bold 13px Arial';
                ctx.fillStyle = '#1976D2';
                for (let i = 0; i < points.length - 1; i++) {
                    if (wallLengths[i] > 0) {
                        const mx = (points[i].x + points[i + 1].x) / 2;
                        const my = (points[i].y + points[i + 1].y) / 2;
                        ctx.fillText(`${wallLengths[i]} ft`, mx - 20, my - 8);
                    }
                }
                
                // PREVIEW label
                ctx.font = 'bold 18px Arial';
                ctx.fillStyle = '#FF9800';
                ctx.fillText('PREVIEW', cx - 45, 30);
                
                // Show turns being applied - DEBUG
                ctx.font = 'bold 12px Arial';
                ctx.fillStyle = '#000';
                let yPos = 50;
                ctx.fillText('Turns:', 10, yPos);
                yPos += 15;
                let hasLeft = false;
                for (let i = 0; i < wallTurns.length; i++) {
                    const color = wallTurns[i] === 'left' ? '#f44336' : '#4CAF50';
                    ctx.fillStyle = color;
                    ctx.fillText(`W${i+1}: ${wallTurns[i].toUpperCase()}`, 10, yPos);
                    yPos += 15;
                    if (wallTurns[i] === 'left') hasLeft = true;
                }
                
                // Big alert if left turn detected
                if (hasLeft) {
                    ctx.font = 'bold 16px Arial';
                    ctx.fillStyle = '#f44336';
                    ctx.fillRect(5, yPos, 250, 30);
                    ctx.fillStyle = '#fff';
                    ctx.fillText('‚ö†Ô∏è LEFT TURN IN ARRAY!', 10, yPos + 20);
                }
                
                ctx.restore();
            } catch(e) {
                console.warn('Preview error:', e);
            }
        }

        function previewFloorPlan() {
            // Compatibility wrapper
            livePreview();
        }


        function applyQuickEntry() {
            const room = getCurrentRoom();
            if (!room) return;
            
            const wallCount = parseInt(document.getElementById('wallCount').value);
            const wallLengths = [];
            const wallTurns = [];
            
            // Get wall lengths
            for (let i = 1; i <= wallCount; i++) {
                const val = parseFloat(document.getElementById(`wall${i}Length`).value);
                if (!val || val <= 0) {
                    showToast('‚ùå Enter all wall lengths');
                    return;
                }
                wallLengths.push(val);
            }
            
            // Get turn directions (default to right)
            for (let i = 1; i < wallCount; i++) {
                const turn = window.wallTurns && window.wallTurns[i] ? window.wallTurns[i] : 'right';
                wallTurns.push(turn);
                console.log(`Wall ${i} turn: ${turn} (from window.wallTurns[${i}] = ${window.wallTurns ? window.wallTurns[i] : 'undefined'})`);
            }
            
            console.log('All turns:', wallTurns);
            console.log('window.wallTurns object:', window.wallTurns);
            
            // VISUAL DEBUG: Show turns on screen
            let debugText = '<div style="background: #fff3cd; padding: 10px; margin: 10px 0; border: 2px solid #ffc107; border-radius: 5px;">';
            debugText += '<strong>üîç Turn Directions:</strong><br>';
            let hasLeftTurn = false;
            for (let i = 0; i < wallTurns.length; i++) {
                const icon = wallTurns[i] === 'left' ? '‚¨ÖÔ∏è' : '‚û°Ô∏è';
                const color = wallTurns[i] === 'left' ? '#f44336' : '#4CAF50';
                debugText += `Wall ${i+1}: ${icon} <span style="color: ${color}; font-weight: bold;">${wallTurns[i].toUpperCase()}</span><br>`;
                if (wallTurns[i] === 'left') hasLeftTurn = true;
            }
            if (hasLeftTurn) {
                debugText += '<div style="background: #f44336; color: white; padding: 8px; margin-top: 10px; border-radius: 4px; font-weight: bold;">‚ö†Ô∏è LEFT TURN DETECTED! Shape should NOT be a rectangle!</div>';
            }
            debugText += '</div>';
            
            // Show it at top of stats panel temporarily
            const statsPanel = document.querySelector('.stats-panel');
            if (statsPanel) {
                const existingDebug = statsPanel.querySelector('.turn-debug');
                if (existingDebug) existingDebug.remove();
                
                const debugDiv = document.createElement('div');
                debugDiv.className = 'turn-debug';
                debugDiv.innerHTML = debugText;
                statsPanel.insertBefore(debugDiv, statsPanel.firstChild);
            }
            
            
            room.ceilingHeight = parseFloat(document.getElementById('ceilingHeight').value);
            room.wallThickness = parseFloat(document.getElementById('wallThickness').value) || 4;
            
            const cx = canvas2D.width / 2;
            const cy = canvas2D.height / 2;
            const scale = 30;
            
            // Build custom floor plan using turn directions
            const points = [];
            let x = cx - 100;
            let y = cy - 100;
            let direction = 0; // 0=right, 1=down, 2=left, 3=up
            
            // Starting point
            points.push({ x, y });
            
            // Place each wall
            const pathDirections = []; // Store for visual display
            
            for (let i = 0; i < wallLengths.length - 1; i++) {
                const length = wallLengths[i] * scale;
                
                const directionName = ['RIGHT ‚Üí','DOWN ‚Üì','LEFT ‚Üê','UP ‚Üë'][direction % 4];
                pathDirections.push(directionName);
                
                console.log(`Wall ${i+1}: length=${wallLengths[i]}ft, direction=${direction} (${directionName})`);
                
                // Move in current direction
                switch(direction % 4) {
                    case 0: x += length; break; // Right
                    case 1: y += length; break; // Down
                    case 2: x -= length; break; // Left
                    case 3: y -= length; break; // Up
                }
                
                points.push({ x, y });
                
                // Turn for next wall
                const turnDir = wallTurns[i];
                console.log(`  After wall ${i+1}, turning: ${turnDir}`);
                
                if (wallTurns[i] === 'right') {
                    direction++; // Turn right (clockwise)
                } else if (wallTurns[i] === 'left') {
                    direction--; // Turn left (counter-clockwise)
                }
                
                // Keep direction in range 0-3 using modulo
                direction = ((direction % 4) + 4) % 4;
                
                console.log(`  New direction: ${direction} (${['RIGHT ‚Üí','DOWN ‚Üì','LEFT ‚Üê','UP ‚Üë'][direction]})`);
            }
            
            // Add visual path display
            const debugDiv = document.querySelector('.turn-debug');
            if (debugDiv) {
                let pathText = '<div style="margin-top: 10px; padding: 10px; background: #e3f2fd; border: 2px solid #2196F3; border-radius: 5px;">';
                pathText += '<strong>üìê Wall Directions:</strong><br>';
                for (let i = 0; i < pathDirections.length; i++) {
                    const turnType = wallTurns[i] || 'none';
                    const turnColor = turnType === 'left' ? '#f44336' : '#4CAF50';
                    pathText += `Wall ${i+1}: ${pathDirections[i]}`;
                    if (i < wallTurns.length) {
                        pathText += ` <span style="color: ${turnColor}; font-weight: bold;">[turn ${turnType.toUpperCase()}]</span>`;
                    }
                    pathText += '<br>';
                }
                pathText += '</div>';
                debugDiv.innerHTML += pathText;
            }
            
            // Last wall closes back to start (don't add point, already have it)
            
            room.floorPoints = points;
            room.walls = [];
            
            for (let i = 0; i < wallLengths.length; i++) {
                room.walls.push({
                    name: `Wall ${i+1}`,
                    start: points[i],
                    end: points[(i+1) % points.length],
                    length: wallLengths[i].toFixed(1)
                });
            }
            
            redraw2D();
            updateStats();
            showToast('‚úì Custom floor plan created!');
        }

        function selectFeature(feature, ev) {
            const room = getCurrentRoom();
            if (!room || room.walls.length === 0) {
                showToast('‚ùå Create floor plan first');
                return;
            }
            
            state.currentFeature = feature;
            state.wallSelectionMode = true;
            state.pendingFeature = null;
            
            document.querySelectorAll('.feature-btn').forEach(b => b.classList.remove('active'));
            const btn = (ev && (ev.currentTarget || ev.target)) ? (ev.currentTarget || ev.target) : null;
            if (btn) btn.classList.add('active');
            
            // Show instruction banner with specific text
            const banner = document.getElementById('instructionBanner');
            if (feature === 'door') {
                banner.textContent = 'üö™ Click on a wall to place door';
            } else if (feature === 'window') {
                banner.textContent = 'ü™ü Click on a wall to place window';
            } else if (feature === 'missing-wall') {
                banner.textContent = 'üß± Click on a wall to add missing section';
            } else {
                banner.textContent = '‚ö†Ô∏è Click to place damage marker';
            }
            banner.classList.add('active');
            
            updateModeIndicator();
            showToast('Walls highlighted - click on any wall');
        }

        canvas2D.addEventListener('mouseup', () => {
            if (state.currentView !== '2d') return; // Only handle in 2D mode
            
            if (isPanning) {
                isPanning = false;
                canvas2D.style.cursor = 'default';
            }
            
            // Feature dragging cleanup
            if (state.draggingFeature) {
                const featureNames = {
                    'door': 'üö™ Door',
                    'window': 'ü™ü Window',
                    'missing': 'üß± Missing wall'
                };
                showToast(`${featureNames[state.draggingFeatureType] || 'Feature'} repositioned`);
                state.draggingFeature = null;
                state.draggingFeatureType = null;
                state.draggingFeatureIndex = null;
                state.draggingFeatureWallIndex = null;
                canvas2D.style.cursor = 'default';
                
                // Update 3D view if active
                if (state.currentView === '3d') {
                    render3D();
                }
                updateStats();
                return;
            }
            
            if (state.draggingRoom !== null) {
                const room = state.rooms[state.draggingRoom];
                if (state.lastSnapped) {
                    const snapMsg = state.snapType ? 
                        `${state.snapType} ${room.name} at (${Math.round(room.positionX)}, ${Math.round(room.positionZ)})` :
                        `‚ö° ${room.name} snapped to (${Math.round(room.positionX)}, ${Math.round(room.positionZ)})`;
                    showToast(snapMsg);
                } else {
                    showToast(`üìç ${room.name} moved to (${Math.round(room.positionX)}, ${Math.round(room.positionZ)})`);
                }
                state.draggingRoom = null;
                state.lastSnapped = false;
                state.snapType = '';
                canvas2D.style.cursor = 'default';
                if (state.currentView === '3d') {
                    render3D();
                }
            }
        });

        canvas2D.addEventListener('mouseleave', () => {
            if (state.currentView !== '2d') return; // Only handle in 2D mode
            
            if (isPanning) {
                isPanning = false;
                canvas2D.style.cursor = 'default';
            }
            
            // Feature dragging cleanup
            if (state.draggingFeature) {
                state.draggingFeature = null;
                state.draggingFeatureType = null;
                state.draggingFeatureIndex = null;
                state.draggingFeatureWallIndex = null;
                canvas2D.style.cursor = 'default';
            }
            
            if (state.draggingRoom !== null) {
                state.draggingRoom = null;
                state.lastSnapped = false;
                state.snapType = '';
                canvas2D.style.cursor = 'default';
            }
        });

        // ========== TOUCH SUPPORT FOR IPAD ==========
        // Add touch-based panning for iPad/iOS devices
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartPanX = 0;
        let touchStartPanY = 0;
        let isTouchPanning = false;
        let lastTouchDistance = 0;
        let touchStartPosition = { x: 0, y: 0 }; // Track where touch started
        let touchMoved = false; // Track if finger actually moved

        canvas2D.addEventListener('touchstart', (e) => {
            if (state.currentView !== '2d') return;
            
            console.log('üëÜ Canvas touch start, touches:', e.touches.length);
            
            if (e.touches.length === 1) {
                // Single finger - might be tap, pan, drag feature, or drag room
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas2D.getBoundingClientRect();
                
                // Calculate touch position
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                const x = (touchX - state.panX) / state.zoom;
                const y = (touchY - state.panY) / state.zoom;
                
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                touchStartPosition = { x: touch.clientX, y: touch.clientY }; // Remember start position
                touchMoved = false; // Reset movement flag
                touchStartPanX = state.panX;
                touchStartPanY = state.panY;
                
                // Check if touching a room for dragging (when Show All Rooms is enabled)
                if (state.showAllRooms && !state.wallSelectionMode && !state.currentFeature) {
                    for (let i = state.rooms.length - 1; i >= 0; i--) {
                        const room = state.rooms[i];
                        if (room.floorPoints.length < 3) continue;
                        
                        const offsetX = (room.positionX || 0) * 30;
                        const offsetZ = (room.positionZ || 0) * 30;
                        
                        // Check if touch point is inside room polygon
                        let inside = false;
                        for (let j = 0, k = room.floorPoints.length - 1; j < room.floorPoints.length; k = j++) {
                            const xi = room.floorPoints[j].x + offsetX;
                            const yi = room.floorPoints[j].y + offsetZ;
                            const xk = room.floorPoints[k].x + offsetX;
                            const yk = room.floorPoints[k].y + offsetZ;
                            
                            if ((yi > y) !== (yk > y) && x < (xk - xi) * (y - yi) / (yk - yi) + xi) {
                                inside = !inside;
                            }
                        }
                        
                        if (inside) {
                            state.draggingRoom = i;
                            state.dragStartX = x;
                            state.dragStartY = y;
                            state.dragStartRoomX = room.positionX || 0;
                            state.dragStartRoomZ = room.positionZ || 0;
                            state.currentRoomIndex = i;
                            isTouchPanning = false; // Don't pan, we're dragging room
                            updateRoomList();
                            redraw2D();
                            console.log('üè† Started dragging room:', room.name);
                            return;
                        }
                    }
                }
                
                // Check if touching a feature (but don't start dragging yet - wait to see if finger moves)
                if (!state.wallSelectionMode && !state.currentFeature) {
                    const room = getCurrentRoom();
                    if (room) {
                        // Check doors
                        for (let i = room.doors.length - 1; i >= 0; i--) {
                            const door = room.doors[i];
                            const dist = Math.sqrt(Math.pow(x - door.x, 2) + Math.pow(y - door.y, 2));
                            if (dist < 50) {
                                // Store potential drag target, but don't start dragging yet
                                state.potentialDragFeature = door;
                                state.potentialDragType = 'door';
                                state.potentialDragIndex = i;
                                isTouchPanning = false; // Don't pan if on feature
                                console.log('üö™ Touching door - waiting to see if tap or drag');
                                return;
                            }
                        }
                        
                        // Check windows
                        for (let i = room.windows.length - 1; i >= 0; i--) {
                            const win = room.windows[i];
                            const dist = Math.sqrt(Math.pow(x - win.x, 2) + Math.pow(y - win.y, 2));
                            if (dist < 50) {
                                // Store potential drag target
                                state.potentialDragFeature = win;
                                state.potentialDragType = 'window';
                                state.potentialDragIndex = i;
                                isTouchPanning = false;
                                console.log('ü™ü Touching window - waiting to see if tap or drag');
                                return;
                            }
                        }
                        
                        // Check openings/missing walls
                        const hitMissing = findMissingAtPoint(room, x, y);
                        if (hitMissing) {
                            const wall = room.walls[hitMissing.wallIdx];
                            if (wall && wall.missingWalls && wall.missingWalls[hitMissing.missIdx]) {
                                // Store potential drag target
                                state.potentialDragFeature = wall.missingWalls[hitMissing.missIdx];
                                state.potentialDragType = 'missing';
                                state.potentialDragIndex = hitMissing.missIdx;
                                state.potentialDragWallIndex = hitMissing.wallIdx;
                                isTouchPanning = false;
                                console.log('üß± Touching opening - waiting to see if tap or drag');
                                return;
                            }
                        }
                    }
                }
                
                // If didn't touch a feature, prepare for pan
                isTouchPanning = true;
                console.log('‚úÖ Single-finger touch started (tap or pan)');
            } else if (e.touches.length === 2) {
                // Two fingers - start pinch zoom
                e.preventDefault();
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Calculate center point for zoom
                touchStartX = (touch1.clientX + touch2.clientX) / 2;
                touchStartY = (touch1.clientY + touch2.clientY) / 2;
                touchStartPanX = state.panX;
                touchStartPanY = state.panY;
                
                // Calculate initial distance for pinch zoom
                const dx = touch2.clientX - touch1.clientX;
                const dy = touch2.clientY - touch1.clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                
                isTouchPanning = true;
                touchMoved = true; // Two-finger is always a gesture, not a tap
                console.log('‚úÖ Two-finger pinch zoom started');
            }
        }, { passive: false });

        canvas2D.addEventListener('touchmove', (e) => {
            if (state.currentView !== '2d') return;
            if (!isTouchPanning && !state.draggingFeature && !state.potentialDragFeature && !state.draggingRoom) return;
            
            e.preventDefault();
            
            const touch = e.touches[0];
            
            // Handle room dragging
            if (state.draggingRoom !== null) {
                const rect = canvas2D.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                const x = (touchX - state.panX) / state.zoom;
                const y = (touchY - state.panY) / state.zoom;
                
                const room = state.rooms[state.draggingRoom];
                const dx = (x - state.dragStartX) / 30; // Convert pixels to position units
                const dy = (y - state.dragStartY) / 30;
                
                let newX = state.dragStartRoomX + dx;
                let newZ = state.dragStartRoomZ + dy;
                
                // Calculate room bounds for snapping
                if (room.floorPoints.length >= 3) {
                    let minX = Infinity, maxX = -Infinity;
                    let minZ = Infinity, maxZ = -Infinity;
                    
                    room.floorPoints.forEach(p => {
                        minX = Math.min(minX, p.x / 30);
                        maxX = Math.max(maxX, p.x / 30);
                        minZ = Math.min(minZ, p.y / 30);
                        maxZ = Math.max(maxZ, p.y / 30);
                    });
                    
                    const roomWidth = maxX - minX;
                    const roomDepth = maxZ - minZ;
                    
                    // Calculate this room's corners in world space
                    const myCorners = [
                        { x: newX + minX, z: newZ + minZ, name: 'TL' },
                        { x: newX + maxX, z: newZ + minZ, name: 'TR' },
                        { x: newX + maxX, z: newZ + maxZ, name: 'BR' },
                        { x: newX + minX, z: newZ + maxZ, name: 'BL' }
                    ];
                    
                    // Check for snapping to other rooms
                    const snapTolerance = 1.0; // Snap if within 1 foot
                    let snapped = false;
                    let snapType = '';
                    
                    state.rooms.forEach((otherRoom, idx) => {
                        if (idx === state.draggingRoom || otherRoom.floorPoints.length < 3) return;
                        
                        let otherMinX = Infinity, otherMaxX = -Infinity;
                        let otherMinZ = Infinity, otherMaxZ = -Infinity;
                        
                        otherRoom.floorPoints.forEach(p => {
                            otherMinX = Math.min(otherMinX, p.x / 30);
                            otherMaxX = Math.max(otherMaxX, p.x / 30);
                            otherMinZ = Math.min(otherMinZ, p.y / 30);
                            otherMaxZ = Math.max(otherMaxZ, p.y / 30);
                        });
                        
                        const otherX = (otherRoom.positionX || 0);
                        const otherZ = (otherRoom.positionZ || 0);
                        
                        // Other room's corners in world space
                        const otherCorners = [
                            { x: otherX + otherMinX, z: otherZ + otherMinZ, name: 'TL' },
                            { x: otherX + otherMaxX, z: otherZ + otherMinZ, name: 'TR' },
                            { x: otherX + otherMaxX, z: otherZ + otherMaxZ, name: 'BR' },
                            { x: otherX + otherMinX, z: otherZ + otherMaxZ, name: 'BL' }
                        ];
                        
                        // CORNER TO CORNER SNAPPING (highest priority)
                        if (!snapped) {
                            for (let i = 0; i < myCorners.length && !snapped; i++) {
                                for (let j = 0; j < otherCorners.length && !snapped; j++) {
                                    const dist = Math.sqrt(
                                        Math.pow(myCorners[i].x - otherCorners[j].x, 2) + 
                                        Math.pow(myCorners[i].z - otherCorners[j].z, 2)
                                    );
                                    
                                    if (dist < snapTolerance * 1.5) {
                                        // Snap this corner to that corner
                                        const offsetX = otherCorners[j].x - myCorners[i].x;
                                        const offsetZ = otherCorners[j].z - myCorners[i].z;
                                        newX += offsetX;
                                        newZ += offsetZ;
                                        snapped = true;
                                        snapType = '‚ö° CORNER';
                                        
                                        // Update corner positions after snap
                                        myCorners[0] = { x: newX + minX, z: newZ + minZ };
                                        myCorners[1] = { x: newX + maxX, z: newZ + minZ };
                                        myCorners[2] = { x: newX + maxX, z: newZ + maxZ };
                                        myCorners[3] = { x: newX + minX, z: newZ + maxZ };
                                        
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // EDGE TO EDGE SNAPPING (if no corner snap)
                        if (!snapped) {
                            // My room's edges
                            const myLeft = newX + minX;
                            const myRight = newX + maxX;
                            const myTop = newZ + minZ;
                            const myBottom = newZ + maxZ;
                            
                            // Other room's edges
                            const otherLeft = otherX + otherMinX;
                            const otherRight = otherX + otherMaxX;
                            const otherTop = otherZ + otherMinZ;
                            const otherBottom = otherZ + otherMaxZ;
                            
                            // Snap right edge to left edge of other room
                            if (Math.abs(myRight - otherLeft) < snapTolerance) {
                                newX = otherLeft - maxX;
                                snapped = true;
                                snapType = '‚ö° EDGE';
                            }
                            // Snap left edge to right edge of other room
                            if (Math.abs(myLeft - otherRight) < snapTolerance) {
                                newX = otherRight - minX;
                                snapped = true;
                                snapType = '‚ö° EDGE';
                            }
                            // Snap bottom edge to top edge of other room
                            if (Math.abs(myBottom - otherTop) < snapTolerance) {
                                newZ = otherTop - maxZ;
                                snapped = true;
                                snapType = '‚ö° EDGE';
                            }
                            // Snap top edge to bottom edge of other room
                            if (Math.abs(myTop - otherBottom) < snapTolerance) {
                                newZ = otherBottom - minZ;
                                snapped = true;
                                snapType = '‚ö° EDGE';
                            }
                        }
                    });
                    
                    state.snapType = snapType;
                    
                    if (snapped) {
                        state.lastSnapped = true;
                    } else {
                        state.lastSnapped = false;
                    }
                }
                
                room.positionX = newX;
                room.positionZ = newZ;
                
                touchMoved = true; // Room was dragged
                redraw2D();
                return;
            }
            
            // Check if finger moved enough to start dragging a potential feature
            if (state.potentialDragFeature && !state.draggingFeature) {
                const distX = Math.abs(touch.clientX - touchStartPosition.x);
                const distY = Math.abs(touch.clientY - touchStartPosition.y);
                
                if (distX > 10 || distY > 10) {
                    // Finger moved enough - convert potential drag to actual drag
                    console.log('üéØ Finger moved - starting drag');
                    saveStateForUndo();
                    state.draggingFeature = state.potentialDragFeature;
                    state.draggingFeatureType = state.potentialDragType;
                    state.draggingFeatureIndex = state.potentialDragIndex;
                    state.draggingFeatureWallIndex = state.potentialDragWallIndex;
                    
                    // Clear potential
                    state.potentialDragFeature = null;
                    state.potentialDragType = null;
                    state.potentialDragIndex = null;
                    state.potentialDragWallIndex = null;
                    
                    touchMoved = true;
                }
            }
            
            // Handle feature dragging
            if (state.draggingFeature) {
                const rect = canvas2D.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                const x = (touchX - state.panX) / state.zoom;
                const y = (touchY - state.panY) / state.zoom;
                
                const room = getCurrentRoom();
                if (!room) return;
                
                if (state.draggingFeatureType === 'door' || state.draggingFeatureType === 'window') {
                    const feature = state.draggingFeatureType === 'door' ? room.doors[state.draggingFeatureIndex] : room.windows[state.draggingFeatureIndex];
                    if (!feature) return;
                    
                    const wall = room.walls[feature.wallIndex];
                    if (!wall) return;
                    
                    // Find closest point on the wall to the touch
                    const wallDx = wall.end.x - wall.start.x;
                    const wallDy = wall.end.y - wall.start.y;
                    const wallLength = Math.sqrt(wallDx * wallDx + wallDy * wallDy);
                    
                    // Project touch position onto wall
                    const touchToWallStartX = x - wall.start.x;
                    const touchToWallStartY = y - wall.start.y;
                    const projection = (touchToWallStartX * wallDx + touchToWallStartY * wallDy) / (wallLength * wallLength);
                    const clampedProjection = Math.max(0, Math.min(1, projection));
                    
                    // Calculate new position on wall
                    feature.x = wall.start.x + clampedProjection * wallDx;
                    feature.y = wall.start.y + clampedProjection * wallDy;
                    
                    // Update distanceFromLeft
                    const wallLengthFt = parseFloat(wall.length);
                    const featureWidthFt = feature.width / 12;
                    const distanceFromStartFt = clampedProjection * wallLengthFt;
                    const edgePosition = distanceFromStartFt - (featureWidthFt / 2);
                    feature.distanceFromLeft = Math.max(0, Math.min(wallLengthFt - featureWidthFt, edgePosition));
                    
                    redraw2D();
                    return;
                    
                } else if (state.draggingFeatureType === 'missing') {
                    const wall = room.walls[state.draggingFeatureWallIndex];
                    const missing = wall.missingWalls[state.draggingFeatureIndex];
                    if (!wall || !missing) return;
                    
                    // Find closest point on the wall to the touch
                    const wallDx = wall.end.x - wall.start.x;
                    const wallDy = wall.end.y - wall.start.y;
                    const wallLength = Math.sqrt(wallDx * wallDx + wallDy * wallDy);
                    
                    // Project touch position onto wall
                    const touchToWallStartX = x - wall.start.x;
                    const touchToWallStartY = y - wall.start.y;
                    const projection = (touchToWallStartX * wallDx + touchToWallStartY * wallDy) / (wallLength * wallLength);
                    const clampedProjection = Math.max(0, Math.min(1, projection));
                    
                    // Calculate segment center position
                    const segmentCenter = clampedProjection * wallLength / 30; // Convert to feet (30 pixels = 1 foot)
                    const segmentWidthFt = (missing.endDist - missing.startDist);
                    
                    // Update both start and end to move the whole segment
                    const newStart = Math.max(0, segmentCenter - segmentWidthFt / 2);
                    const newEnd = Math.min(wallLength / 30, segmentCenter + segmentWidthFt / 2);
                    
                    missing.startDist = newStart;
                    missing.endDist = newEnd;
                    
                    redraw2D();
                    return;
                }
            }
            
            // Handle panning if not dragging
            if (isTouchPanning && e.touches.length === 1) {
                // Single finger pan
                const touch = e.touches[0];
                
                // Check if finger moved more than 10 pixels from start
                const distX = Math.abs(touch.clientX - touchStartPosition.x);
                const distY = Math.abs(touch.clientY - touchStartPosition.y);
                if (distX > 10 || distY > 10) {
                    touchMoved = true; // Finger moved = pan, not tap
                }
                
                const dx = touch.clientX - touchStartX;
                const dy = touch.clientY - touchStartY;
                
                state.panX = touchStartPanX + dx;
                state.panY = touchStartPanY + dy;
                
                redraw2D();
            } else if (e.touches.length === 2) {
                // Two finger pinch zoom + pan
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Calculate new center
                const centerX = (touch1.clientX + touch2.clientX) / 2;
                const centerY = (touch1.clientY + touch2.clientY) / 2;
                
                // Pan based on center movement
                const dx = centerX - touchStartX;
                const dy = centerY - touchStartY;
                state.panX = touchStartPanX + dx;
                state.panY = touchStartPanY + dy;
                
                // Calculate new distance for zoom
                const dx2 = touch2.clientX - touch1.clientX;
                const dy2 = touch2.clientY - touch1.clientY;
                const newDistance = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                
                // Apply pinch zoom
                if (lastTouchDistance > 0) {
                    const zoomFactor = newDistance / lastTouchDistance;
                    const oldZoom = state.zoom;
                    state.zoom = Math.max(0.1, Math.min(5, state.zoom * zoomFactor));
                    
                    // Adjust pan to zoom toward touch point
                    const rect = canvas2D.getBoundingClientRect();
                    const mouseX = centerX - rect.left;
                    const mouseY = centerY - rect.top;
                    const worldX = (mouseX - state.panX) / oldZoom;
                    const worldY = (mouseY - state.panY) / oldZoom;
                    state.panX = mouseX - worldX * state.zoom;
                    state.panY = mouseY - worldY * state.zoom;
                    
                    document.getElementById('zoomLevel').textContent = Math.round(state.zoom * 100) + '%';
                }
                
                lastTouchDistance = newDistance;
                redraw2D();
            }
        }, { passive: false });

        canvas2D.addEventListener('touchend', (e) => {
            // Store touch info for tap detection
            const fingerMoved = touchMoved; // Did the finger actually move?
            const touchCount = e.changedTouches.length;
            
            // Room dragging cleanup
            if (state.draggingRoom !== null) {
                const room = state.rooms[state.draggingRoom];
                if (state.lastSnapped) {
                    const snapMsg = state.snapType ? 
                        `${state.snapType} ${room.name} at (${Math.round(room.positionX)}, ${Math.round(room.positionZ)})` :
                        `‚ö° ${room.name} snapped to (${Math.round(room.positionX)}, ${Math.round(room.positionZ)})`;
                    showToast(snapMsg);
                } else {
                    showToast(`üìç ${room.name} moved to (${Math.round(room.positionX)}, ${Math.round(room.positionZ)})`);
                }
                state.draggingRoom = null;
                state.lastSnapped = false;
                state.snapType = '';
                if (state.currentView === '3d') {
                    render3D();
                }
                console.log('‚úÖ Room drag ended');
                return; // Don't treat room drag end as a tap
            }
            
            // Feature dragging cleanup
            if (state.draggingFeature) {
                const featureNames = {
                    'door': 'üö™ Door',
                    'window': 'ü™ü Window',
                    'missing': 'üß± Opening'
                };
                showToast(`${featureNames[state.draggingFeatureType] || 'Feature'} repositioned`);
                state.draggingFeature = null;
                state.draggingFeatureType = null;
                state.draggingFeatureIndex = null;
                state.draggingFeatureWallIndex = null;
                console.log('‚úÖ Drag ended');
                return; // Don't treat drag end as a tap
            }
            
            // If we had a potential drag but finger didn't move, it's a TAP to EDIT
            if (state.potentialDragFeature && !fingerMoved) {
                console.log('üéØ Quick tap on feature - opening edit modal');
                const room = getCurrentRoom();
                if (room) {
                    if (state.potentialDragType === 'door') {
                        showPositionModal('door', state.potentialDragIndex);
                    } else if (state.potentialDragType === 'window') {
                        showPositionModal('window', state.potentialDragIndex);
                    } else if (state.potentialDragType === 'missing') {
                        showMissingWallEditModal(state.currentRoomIndex, state.potentialDragWallIndex, state.potentialDragIndex);
                    }
                }
                
                // Clear potential drag
                state.potentialDragFeature = null;
                state.potentialDragType = null;
                state.potentialDragIndex = null;
                state.potentialDragWallIndex = null;
                return; // Don't continue to wall click logic
            }
            
            // Clear potential drag if it exists
            if (state.potentialDragFeature) {
                state.potentialDragFeature = null;
                state.potentialDragType = null;
                state.potentialDragIndex = null;
                state.potentialDragWallIndex = null;
            }
            
            if (e.touches.length === 0) {
                isTouchPanning = false;
                lastTouchDistance = 0;
                console.log('‚úÖ Touch panning ended');
                
                // If finger DIDN'T move (tap, not pan), trigger click logic for PLACEMENT
                // FIXED: Always call handleWallClick on tap, not just in wallSelectionMode
                if (!fingerMoved && touchCount === 1) {
                    const touch = e.changedTouches[0];
                    console.log('üéØ TAP DETECTED (no movement)! Calling handleWallClick...');
                    
                    // Create a fake click event for the wall selection logic
                    const fakeEvent = {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        shiftKey: false,
                        preventDefault: () => {},
                        stopPropagation: () => {}
                    };
                    
                    // Manually trigger the wall click logic
                    handleWallClick(fakeEvent);
                }
            } else if (e.touches.length === 1 && isTouchPanning) {
                // One finger lifted during two-finger gesture, restart with one finger
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                touchStartPanX = state.panX;
                touchStartPanY = state.panY;
                lastTouchDistance = 0;
            }
        }, { passive: false });

        canvas2D.addEventListener('touchcancel', () => {
            isTouchPanning = false;
            lastTouchDistance = 0;
            
            // Room dragging cleanup
            if (state.draggingRoom !== null) {
                state.draggingRoom = null;
                state.lastSnapped = false;
                state.snapType = '';
            }
            
            // Feature dragging cleanup
            if (state.draggingFeature) {
                state.draggingFeature = null;
                state.draggingFeatureType = null;
                state.draggingFeatureIndex = null;
                state.draggingFeatureWallIndex = null;
            }
            
            // Potential drag cleanup
            if (state.potentialDragFeature) {
                state.potentialDragFeature = null;
                state.potentialDragType = null;
                state.potentialDragIndex = null;
                state.potentialDragWallIndex = null;
            }
            
            console.log('Touch cancelled');
        }, { passive: false });

        // Handle wall clicks for feature placement (called from both mouse and touch events)
        function handleWallClick(e) {
            if (state.currentView !== '2d') return; // Only handle in 2D mode
            
            const room = getCurrentRoom();
            if (!room) return;
            
            const rect = canvas2D.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            // Transform click coordinates to account for zoom and pan
            const x = (clickX - state.panX) / state.zoom;
            const y = (clickY - state.panY) / state.zoom;
            
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('CANVAS CLICKED');
            console.log('Position:', x, y);
            console.log('wallSelectionMode:', state.wallSelectionMode);
            console.log('currentFeature:', state.currentFeature);
            console.log('Room has', room.doors.length, 'doors and', room.windows.length, 'windows');
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            
            // MODE 1: Reposition OR Delete doors/windows - when NOT in any placement mode
            if (!state.wallSelectionMode && !state.currentFeature) {
                console.log('‚úì IN REPOSITION/DELETE MODE');
                console.log('Shift key:', e.shiftKey);
                console.log('Checking doors and windows...');
                
                
            // Check wall cuts (Shift+Click to delete, Click to edit)
            if (!state.wallSelectionMode && !state.currentFeature) {
                const hitCut = findClickedCut(room, x, y);
                if (hitCut) {
                    if (e.shiftKey) {
                        // Quick delete
                        const wall = room.walls[hitCut.wallIdx];
                        if (wall && wall.cuts && wall.cuts[hitCut.cutIdx]) {
                            saveStateForUndo();
                            wall.cuts.splice(hitCut.cutIdx, 1);
                            if (wall.cuts.length === 0) delete wall.cuts;
                            showToast('üóëÔ∏è Cut removed (Shift+Click)');
                            redraw2D();
                            if (state.currentView === '3d') render3D();
                            updateStats();
                        }
                    } else {
                        showCutWallEditModal(state.currentRoomIndex, hitCut.wallIdx, hitCut.cutIdx);
                    }
                    return;
                }
            }

// Check doors first
                
                // Check missing walls (Shift+Click to delete, Click to edit)
                const hitMissing = findMissingAtPoint(room, x, y);
                if (hitMissing) {
                    const wall = room.walls[hitMissing.wallIdx];
                    if (e.shiftKey) {
                        if (wall && wall.missingWalls && wall.missingWalls[hitMissing.missIdx]) {
                            saveStateForUndo();
                            wall.missingWalls.splice(hitMissing.missIdx, 1);
                            if (wall.missingWalls.length === 0) delete wall.missingWalls;
                            showToast('üß± Missing wall deleted (Shift+Click)');
                            redraw2D();
                            if (state.currentView === '3d') render3D();
                            updateStats();
                            return;
                        }
                    } else {
                        showMissingWallEditModal(state.currentRoomIndex, hitMissing.wallIdx, hitMissing.missIdx);
                        return;
                    }
                }

for (let i = room.doors.length - 1; i >= 0; i--) {
                    const door = room.doors[i];
                    const dist = Math.sqrt(Math.pow(x - door.x, 2) + Math.pow(y - door.y, 2));
                    console.log(`  Door ${i}: position=(${door.x}, ${door.y}), distance=${dist.toFixed(2)}`);
                    if (dist < 50) {
                        if (e.shiftKey) {
                            // Delete with Shift+Click
                            console.log(`  ‚úì‚úì‚úì DOOR ${i} IS CLOSE ENOUGH (${dist.toFixed(2)} < 50) - DELETING NOW`);
                            room.doors.splice(i, 1);
                            console.log('  ‚úì‚úì‚úì DOOR DELETED');
                            showToast('üö™ Door deleted (Shift+Click)');
                            redraw2D();
                            updateStats();
                            return;
                        } else {
                            // Reposition with regular click
                            console.log(`  ‚úì OPENING POSITION EDITOR for Door ${i}`);
                            showPositionModal('door', i);
                            return;
                        }
                    }
                }
                
                // Check windows
                for (let i = room.windows.length - 1; i >= 0; i--) {
                    const win = room.windows[i];
                    const dist = Math.sqrt(Math.pow(x - win.x, 2) + Math.pow(y - win.y, 2));
                    console.log(`  Window ${i}: position=(${win.x}, ${win.y}), distance=${dist.toFixed(2)}`);
                    if (dist < 50) {
                        if (e.shiftKey) {
                            // Delete with Shift+Click
                            console.log(`  ‚úì‚úì‚úì WINDOW ${i} IS CLOSE ENOUGH (${dist.toFixed(2)} < 50) - DELETING NOW`);
                            room.windows.splice(i, 1);
                            console.log('  ‚úì‚úì‚úì WINDOW DELETED');
                            showToast('ü™ü Window deleted (Shift+Click)');
                            redraw2D();
                            updateStats();
                            return;
                        } else {
                            // Reposition with regular click
                            console.log(`  ‚úì OPENING POSITION EDITOR for Window ${i}`);
                            showPositionModal('window', i);
                            return;
                        }
                    }
                }
                
                console.log('‚úó No door/window close enough to click point');
                return; // Exit - didn't click on anything
            }
            
            // MODE 2: Place door/window on wall
            if (state.wallSelectionMode && (state.currentFeature === 'door' || state.currentFeature === 'window')) {
                console.log('‚úì IN WALL SELECTION MODE - placing', state.currentFeature);
                
                // Find which wall was clicked and exact click point on wall
                let clickedWall = null;
                let minDist = Infinity;
                let closestPoint = null;
                
                room.walls.forEach((wall, index) => {
                    const dist = distanceToLineSegment(x, y, wall.start.x, wall.start.y, wall.end.x, wall.end.y);
                    if (dist < 30 && dist < minDist) {
                        minDist = dist;
                        
                        // Calculate closest point on the wall line
                        const A = x - wall.start.x;
                        const B = y - wall.start.y;
                        const C = wall.end.x - wall.start.x;
                        const D = wall.end.y - wall.start.y;
                        
                        const dot = A * C + B * D;
                        const lenSq = C * C + D * D;
                        let param = -1;
                        if (lenSq !== 0) param = dot / lenSq;
                        
                        // Clamp to wall segment
                        param = Math.max(0, Math.min(1, param));
                        
                        const pointX = wall.start.x + param * C;
                        const pointY = wall.start.y + param * D;
                        
                        // Calculate distance from start of wall in feet
                        const wallLength = Math.sqrt(C * C + D * D);
                        const distanceFromStart = Math.sqrt(
                            Math.pow(pointX - wall.start.x, 2) + 
                            Math.pow(pointY - wall.start.y, 2)
                        );
                        const distanceInFeet = (distanceFromStart / 30) * 1; // 30 pixels = 1 foot scale
                        
                        clickedWall = { wall, index };
                        closestPoint = { 
                            x: pointX, 
                            y: pointY,
                            distanceFromStart: distanceInFeet
                        };
                    }
                });
                
                if (clickedWall && closestPoint) {
                    state.selectedWall = clickedWall.index;
                    state.clickPoint = closestPoint;
                    if (state.currentFeature === 'missing-wall') {
                        // Missing wall uses its own modal
                        showMissingWallModal();
                        // keep edit mode after opening modal
                        state.wallSelectionMode = false;
                        updateModeIndicator();
                    } else {
                        showPlacementDialog();
                    }
                } else {
                    showToast('‚ùå Click closer to a wall');
                }
                return;
            }
            // MODE 2b: Add Missing Wall segment on a wall (Xactimate-style)
            if (state.wallSelectionMode && state.currentFeature === 'missing-wall') {
                console.log('‚úì IN WALL SELECTION MODE - missing wall');

                // Find which wall was clicked
                let clickedWall = null;
                let minDist = Infinity;

                room.walls.forEach((wall, index) => {
                    const dist = distanceToLineSegment(x, y, wall.start.x, wall.start.y, wall.end.x, wall.end.y);
                    console.log(`Wall ${index}: distance = ${dist}`);
                    if (dist < 30 && dist < minDist) {
                        minDist = dist;
                        clickedWall = { wall, index };
                    }
                });

                if (!clickedWall) {
                    showToast('‚ùå Click on a wall');
                    return;
                }

                // Select this wall, open modal, and exit selection mode
                state.selectedWall = clickedWall.index;
                showMissingWallModal();

                state.currentFeature = null;
                state.wallSelectionMode = false;
                document.querySelectorAll('.feature-btn').forEach(b => b.classList.remove('active'));
                document.getElementById('instructionBanner').classList.remove('active');
                redraw2D();
                return;
            }

            
            // MODE 3: Place damage marker (anywhere on floor)
            if (state.currentFeature && state.currentFeature.includes('damage')) {
                console.log('‚úì IN DAMAGE MARKER MODE - placing', state.currentFeature);
                room.damageMarkers.push({
                    type: state.currentFeature,
                    x: x - 50,
                    y: y - 50,
                    width: 100,
                    height: 100
                });
                showToast('‚ö†Ô∏è Damage marked');
                state.currentFeature = null;
                state.wallSelectionMode = false;
                document.querySelectorAll('.feature-btn').forEach(b => b.classList.remove('active'));
                document.getElementById('instructionBanner').classList.remove('active');
                redraw2D();
                updateStats();
            }
        }
        
        // Add click event listener
        canvas2D.addEventListener('click', handleWallClick);

        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) param = dot / lenSq;
            
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function showPlacementDialog() {
            const dialog = document.getElementById('placementDialog');
            const title = document.getElementById('dialogTitle');
            const heightField = document.getElementById('heightField');
            
            if (state.currentFeature === 'door') {
                title.textContent = 'Add Door';
                document.getElementById('featureWidth').value = 36; // 3.0 feet
                document.getElementById('featureHeight').value = 80; // 6'8" standard height
                heightField.style.display = 'block';
                document.getElementById('heightFieldLabel').textContent = 'Height (inches)';
                document.getElementById('windowHeightField').style.display = 'none';
            } else if (state.currentFeature === 'window') {
                title.textContent = 'Add Window';
                document.getElementById('featureWidth').value = 36; // 3.0 feet width
                document.getElementById('featureWindowHeight').value = 36; // 3.0 feet height
                document.getElementById('featureHeight').value = 3.0; // 3.0 feet from floor
                heightField.style.display = 'block';
                document.getElementById('heightFieldLabel').textContent = 'Height from Floor (feet)';
                document.getElementById('windowHeightField').style.display = 'block';
            }
            
            dialog.classList.add('active');
        }

        function cancelPlacement() {
            document.getElementById('placementDialog').classList.remove('active');
            document.getElementById('instructionBanner').classList.remove('active');
            state.wallSelectionMode = false;
            state.selectedWall = null;
            state.hoveredWall = null;
            state.clickPoint = null;
            state.currentFeature = null;
            document.querySelectorAll('.feature-btn').forEach(b => b.classList.remove('active'));
            updateModeIndicator();
            redraw2D();
        }

        function confirmPlacement() {
            const room = getCurrentRoom();
            if (!room || state.selectedWall === null || !state.clickPoint) return;
            
            const wall = room.walls[state.selectedWall];
            const width = parseFloat(document.getElementById('featureWidth').value);
            const widthFt = width / 12; // Convert inches to feet
            const heightFromFloor = state.currentFeature === 'window' ? 
                parseFloat(document.getElementById('featureHeight').value) : 0;
            
            // The click point is the CENTER of where user clicked
            // Calculate the LEFT EDGE position (for distanceFromLeft)
            const clickCenterDistance = state.clickPoint.distanceFromStart;
            const edgePosition = clickCenterDistance - (widthFt / 2);
            
            // Make sure feature fits on wall
            const wallLength = parseFloat(wall.length);
            if (edgePosition < 0 || (edgePosition + widthFt) > wallLength) {
                // Adjust to fit on wall
                const adjustedEdge = Math.max(0, Math.min(edgePosition, wallLength - widthFt));
                const adjustedCenter = adjustedEdge + (widthFt / 2);
                
                // Recalculate x, y for adjusted position
                const param = adjustedCenter / wallLength;
                const wallDx = wall.end.x - wall.start.x;
                const wallDy = wall.end.y - wall.start.y;
                const x = wall.start.x + param * wallDx;
                const y = wall.start.y + param * wallDy;
                
                // Calculate rotation to match wall angle
                const rotation = Math.atan2(wallDy, wallDx) * 180 / Math.PI;
                
                // Add the feature
                const feature = {
                    x,
                    y,
                    width,
                    rotation,
                    wallIndex: state.selectedWall,
                    distanceFromLeft: adjustedEdge // Store EDGE position
                };
                
                if (state.currentFeature === 'door') {
                    feature.height = parseFloat(document.getElementById('featureHeight').value); // Store door height in inches
                    feature.hinge = 'right'; // Default hinge side (right)
                    feature.swingDirection = 'in'; // Default swing direction (into room)
                    room.doors.push(feature);
                    showToast(`üö™ Door added at ${adjustedEdge.toFixed(1)} ft (adjusted to fit)`);
                } else if (state.currentFeature === 'window') {
                    feature.heightFromFloor = heightFromFloor;
                    feature.height = parseFloat(document.getElementById('featureWindowHeight').value); // Get window height from input
                    room.windows.push(feature);
                    showToast(`ü™ü Window added at ${adjustedEdge.toFixed(1)} ft (adjusted to fit)`);
                }
            } else {
                // Feature fits normally
                // Use the exact click point on the wall (center)
                const x = state.clickPoint.x;
                const y = state.clickPoint.y;
                
                // Calculate rotation to match wall angle
                const wallDx = wall.end.x - wall.start.x;
                const wallDy = wall.end.y - wall.start.y;
                const rotation = Math.atan2(wallDy, wallDx) * 180 / Math.PI;
                
                // Add the feature
                const feature = {
                    x,
                    y,
                    width,
                    rotation,
                    wallIndex: state.selectedWall,
                    distanceFromLeft: edgePosition // Store EDGE position
                };
                
                if (state.currentFeature === 'door') {
                    feature.height = parseFloat(document.getElementById('featureHeight').value); // Store door height in inches
                    feature.hinge = 'right'; // Default hinge side (right)
                    feature.swingDirection = 'in'; // Default swing direction (into room)
                    room.doors.push(feature);
                    showToast(`üö™ Door added - left edge at ${edgePosition.toFixed(1)} ft from left`);
                } else if (state.currentFeature === 'window') {
                    feature.heightFromFloor = heightFromFloor;
                    feature.height = parseFloat(document.getElementById('featureWindowHeight').value); // Get window height from input
                    room.windows.push(feature);
                    showToast(`ü™ü Window added - left edge at ${edgePosition.toFixed(1)} ft from left`);
                }
            }
            
            // Reset state
            document.getElementById('placementDialog').classList.remove('active');
            document.getElementById('instructionBanner').classList.remove('active');
            state.wallSelectionMode = false;
            state.selectedWall = null;
            state.hoveredWall = null;
            state.clickPoint = null;
            state.currentFeature = null;
            document.querySelectorAll('.feature-btn').forEach(b => b.classList.remove('active'));
            
            updateModeIndicator();
            redraw2D();
            updateStats();
        }

        function zoomIn() {
            state.zoom = Math.min(state.zoom * 1.2, 5);
            document.getElementById('zoomLevel').textContent = Math.round(state.zoom * 100) + '%';
            redraw2D();
        }

        function zoomOut() {
            state.zoom = Math.max(state.zoom / 1.2, 0.1);
            document.getElementById('zoomLevel').textContent = Math.round(state.zoom * 100) + '%';
            redraw2D();
        }

        function resetZoom() {
            state.zoom = 1;
            state.panX = 0;
            state.panY = 0;
            document.getElementById('zoomLevel').textContent = '100%';
            redraw2D();
        }

        function zoomAll() {
            const room = getCurrentRoom();
            if (!room || room.floorPoints.length === 0) {
                resetZoom();
                return;
            }
            
            // Calculate bounds of room
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            room.floorPoints.forEach(p => {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            });
            
            // Add padding (10% of room size)
            const width = maxX - minX;
            const height = maxY - minY;
            const padding = Math.max(width, height) * 0.1;
            
            minX -= padding;
            maxX += padding;
            minY -= padding;
            maxY += padding;
            
            // Calculate zoom to fit in canvas
            const canvasWidth = canvas2D.width;
            const canvasHeight = canvas2D.height;
            const roomWidth = maxX - minX;
            const roomHeight = maxY - minY;
            
            const zoomX = canvasWidth / roomWidth;
            const zoomY = canvasHeight / roomHeight;
            state.zoom = Math.min(zoomX, zoomY, 3); // Max zoom of 3x
            
            // Calculate pan to center room
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            
            state.panX = canvasWidth / 2 - centerX * state.zoom;
            state.panY = canvasHeight / 2 - centerY * state.zoom;
            
            document.getElementById('zoomLevel').textContent = Math.round(state.zoom * 100) + '%';
            redraw2D();
            showToast('üîç Zoomed to fit room');
        }

        function toggleShowAllRooms() {
            state.showAllRooms = document.getElementById('showAllRooms').checked;
            document.getElementById('allRoomsHelp').style.display = state.showAllRooms ? 'block' : 'none';
            
            if (state.showAllRooms) {
                // Calculate bounds of all rooms for auto-fitting
                zoomToFitAllRooms();
                showToast('üèòÔ∏è Showing all rooms - Click and drag to move');
            } else {
                resetZoom();
                showToast('üìê Showing single room');
            }
            
            redraw2D();
        }

        function zoomToFitAllRooms() {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            state.rooms.forEach(room => {
                if (room.floorPoints.length === 0) return;
                
                const offsetX = (room.positionX || 0) * 30;
                const offsetZ = (room.positionZ || 0) * 30;
                
                room.floorPoints.forEach(p => {
                    minX = Math.min(minX, p.x + offsetX);
                    maxX = Math.max(maxX, p.x + offsetX);
                    minY = Math.min(minY, p.y + offsetZ);
                    maxY = Math.max(maxY, p.y + offsetZ);
                });
            });
            
            if (minX === Infinity) {
                resetZoom();
                return;
            }
            
            // Add padding
            const width = maxX - minX;
            const height = maxY - minY;
            const padding = Math.max(width, height) * 0.15;
            
            minX -= padding;
            maxX += padding;
            minY -= padding;
            maxY += padding;
            
            // Calculate zoom
            const canvasWidth = canvas2D.width;
            const canvasHeight = canvas2D.height;
            const totalWidth = maxX - minX;
            const totalHeight = maxY - minY;
            
            const zoomX = canvasWidth / totalWidth;
            const zoomY = canvasHeight / totalHeight;
            state.zoom = Math.min(zoomX, zoomY, 2);
            
            // Center view
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            
            state.panX = canvasWidth / 2 - centerX * state.zoom;
            state.panY = canvasHeight / 2 - centerY * state.zoom;
            
            document.getElementById('zoomLevel').textContent = Math.round(state.zoom * 100) + '%';
        }

        function drawSingleRoom(room, offsetX, offsetZ, isCurrentRoom) {
            if (room.floorPoints.length < 3) return;
            
            ctx.save();
            
            // Apply room offset for multi-room view
            if (state.showAllRooms) {
                ctx.translate(offsetX, offsetZ);
            }
            
            // Draw floor
            ctx.fillStyle = isCurrentRoom ? 'rgba(200, 230, 255, 0.3)' : 'rgba(240, 240, 240, 0.3)';
            ctx.strokeStyle = isCurrentRoom ? '#1e3c72' : '#999';
            ctx.lineWidth = (isCurrentRoom ? 3 : 2) / state.zoom;
            ctx.beginPath();
            ctx.moveTo(room.floorPoints[0].x, room.floorPoints[0].y);
            room.floorPoints.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw room label for multi-room view
            if (state.showAllRooms) {
                const centerX = room.floorPoints.reduce((sum, p) => sum + p.x, 0) / room.floorPoints.length;
                const centerY = room.floorPoints.reduce((sum, p) => sum + p.y, 0) / room.floorPoints.length;
                
                ctx.font = `bold ${18 / state.zoom}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillStyle = isCurrentRoom ? '#1e3c72' : '#666';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3 / state.zoom;
                ctx.strokeText(room.name, centerX, centerY);
                ctx.fillText(room.name, centerX, centerY);
            }
            
            // Draw walls with labels (show cuts as gaps)
            room.walls.forEach((wall, wallIdx) => {
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 4 / state.zoom;
                
                const wallCuts = [...(wall.cuts || []), ...(wall.missingWalls || [])];
                const wallLength = parseFloat(wall.length);
                const scale = 30; // pixels per foot
                
                if (wallCuts.length === 0) {
                    // No cuts - draw complete wall
                    ctx.beginPath();
                    ctx.moveTo(wall.start.x, wall.start.y);
                    ctx.lineTo(wall.end.x, wall.end.y);
                    ctx.stroke();
                } else {
                    // Draw wall in segments, skipping cut portions
                    const dx = wall.end.x - wall.start.x;
                    const dy = wall.end.y - wall.start.y;
                    const wallPixelLength = Math.sqrt(dx * dx + dy * dy);
                    const unitX = dx / wallPixelLength;
                    const unitY = dy / wallPixelLength;
                    
                    // Sort cuts by start distance
                    wallCuts.sort((a, b) => a.startDist - b.startDist);
                    
                    let currentPos = 0; // in feet
                    
                    wallCuts.forEach(cut => {
                        // Draw segment before cut
                        if (cut.startDist > currentPos) {
                            const startPixel = currentPos * scale;
                            const endPixel = cut.startDist * scale;
                            
                            ctx.beginPath();
                            ctx.moveTo(
                                wall.start.x + unitX * startPixel,
                                wall.start.y + unitY * startPixel
                            );
                            ctx.lineTo(
                                wall.start.x + unitX * endPixel,
                                wall.start.y + unitY * endPixel
                            );
                            ctx.stroke();
                        }
                        currentPos = cut.endDist;
                    });
                    
                    // Draw final segment after last cut
                    if (currentPos < wallLength) {
                        const startPixel = currentPos * scale;
                        const endPixel = wallLength * scale;
                        
                        ctx.beginPath();
                        ctx.moveTo(
                            wall.start.x + unitX * startPixel,
                            wall.start.y + unitY * startPixel
                        );
                        ctx.lineTo(
                            wall.start.x + unitX * endPixel,
                            wall.start.y + unitY * endPixel
                        );
                        ctx.stroke();
                    }
                    
                    // Draw red markers at cut locations
                    ctx.strokeStyle = '#FF0000';
                    ctx.lineWidth = 3 / state.zoom;
                    ctx.setLineDash([5 / state.zoom, 5 / state.zoom]);
                    
                    wallCuts.forEach(cut => {
                        const startPixel = cut.startDist * scale;
                        const endPixel = cut.endDist * scale;
                        const midPixel = (startPixel + endPixel) / 2;
                        
                        // Draw perpendicular markers
                        const perpX = -unitY * 15 / state.zoom;
                        const perpY = unitX * 15 / state.zoom;
                        
                        // Start marker
                        ctx.beginPath();
                        ctx.moveTo(
                            wall.start.x + unitX * startPixel,
                            wall.start.y + unitY * startPixel
                        );
                        ctx.lineTo(
                            wall.start.x + unitX * startPixel + perpX,
                            wall.start.y + unitY * startPixel + perpY
                        );
                        ctx.stroke();
                        
                        // End marker
                        ctx.beginPath();
                        ctx.moveTo(
                            wall.start.x + unitX * endPixel,
                            wall.start.y + unitY * endPixel
                        );
                        ctx.lineTo(
                            wall.start.x + unitX * endPixel + perpX,
                            wall.start.y + unitY * endPixel + perpY
                        );
                        ctx.stroke();
                        
                        // "CUT" text label
                        ctx.save();
                        ctx.translate(
                            wall.start.x + unitX * midPixel,
                            wall.start.y + unitY * midPixel
                        );
                        ctx.rotate(Math.atan2(dy, dx));
                        ctx.setLineDash([]);
                        ctx.fillStyle = '#FF0000';
                        ctx.font = `bold ${10 / state.zoom}px Arial`;
                        ctx.textAlign = 'center';
                        // Show cut label + cut length dimension
                        const cutLenFt = (cut.endDist - cut.startDist);
                        ctx.fillText('CUT', 0, -8 / state.zoom);
                        ctx.font = `bold ${9 / state.zoom}px Arial`;
                        ctx.fillText(`${cutLenFt.toFixed(2)}'`, 0, 6 / state.zoom);

                        // Corner-to-opening edge dimensions (from each wall corner to the nearest cut edge)
                        // Left corner -> cut.startDist, and right corner -> (wallLength - cut.endDist)
                        const wallAngle2D = Math.atan2(dy, dx);
                        const nX = -unitY;
                        const nY = unitX;
                        const dimOffset = 28 / state.zoom;   // push dims off the wall a bit
                        const dimTick = 10 / state.zoom;

                        function drawDimSegment(aFeet, bFeet, labelFeet, labelMidFeet) {
                            const aPix = aFeet * scale;
                            const bPix = bFeet * scale;
                            const midPix = labelMidFeet * scale;

                            // Dimension baseline (parallel to wall, offset outward)
                            const x1 = wall.start.x + unitX * aPix + nX * dimOffset;
                            const y1 = wall.start.y + unitY * aPix + nY * dimOffset;
                            const x2 = wall.start.x + unitX * bPix + nX * dimOffset;
                            const y2 = wall.start.y + unitY * bPix + nY * dimOffset;

                            ctx.save();
                            ctx.setLineDash([]);
                            ctx.strokeStyle = '#111';
                            ctx.lineWidth = 2 / state.zoom;

                            // Baseline
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();

                            // End ticks
                            const tpx = -unitY * dimTick;
                            const tpy = unitX * dimTick;

                            ctx.beginPath();
                            ctx.moveTo(x1 - tpx, y1 - tpy);
                            ctx.lineTo(x1 + tpx, y1 + tpy);
                            ctx.stroke();

                            ctx.beginPath();
                            ctx.moveTo(x2 - tpx, y2 - tpy);
                            ctx.lineTo(x2 + tpx, y2 + tpy);
                            ctx.stroke();

                            // Label
                            ctx.translate(
                                wall.start.x + unitX * midPix + nX * (dimOffset + 14 / state.zoom),
                                wall.start.y + unitY * midPix + nY * (dimOffset + 14 / state.zoom)
                            );
                            ctx.rotate(wallAngle2D);
                            ctx.font = `bold ${10 / state.zoom}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillStyle = '#111';
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 3 / state.zoom;
                            const label = `${labelFeet.toFixed(2)}'`;
                            ctx.strokeText(label, 0, 0);
                            ctx.fillText(label, 0, 0);

                            ctx.restore();
                        }

                        const leftLenFt = Math.max(0, cut.startDist);
                        const rightLenFt = Math.max(0, wallLength - cut.endDist);

                        // left segment: 0 -> cut.startDist
                        if (leftLenFt > 0.01) {
                            drawDimSegment(0, cut.startDist, leftLenFt, leftLenFt / 2);
                        }
                        // right segment: cut.endDist -> wallLength
                        if (rightLenFt > 0.01) {
                            drawDimSegment(cut.endDist, wallLength, rightLenFt, cut.endDist + rightLenFt / 2);
                        }

                        ctx.restore();
                    });
                    
                    ctx.setLineDash([]);
                    ctx.strokeStyle = '#333';
                }
                
                // Calculate wall angle and midpoint
                const mx = (wall.start.x + wall.end.x) / 2;
                const my = (wall.start.y + wall.end.y) / 2;
                const dx = wall.end.x - wall.start.x;
                const dy = wall.end.y - wall.start.y;
                const angle = Math.atan2(dy, dx);
                
                // Draw dimension text aligned with wall
                ctx.save();
                ctx.translate(mx, my);
                
                // Rotate text to align with wall
                // Keep text upright (don't let it be upside down)
                let textAngle = angle;
                if (Math.abs(angle) > Math.PI / 2) {
                    textAngle = angle + Math.PI;
                }
                ctx.rotate(textAngle);
                
                // Draw text
                ctx.fillStyle = '#1e3c72';
                ctx.font = `bold ${12 / state.zoom}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                
                // Offset text slightly above the wall
                ctx.fillText(`${wall.name}: ${wall.length} ft`, 0, -8 / state.zoom);
                
                ctx.restore();
            });
            
            // Draw interior dimensions for doors and windows along walls
            if (!state.showAllRooms || isCurrentRoom) {
                room.walls.forEach((wall, wallIndex) => {
                    const wallLength = parseFloat(wall.length);
                    const dx = wall.end.x - wall.start.x;
                    const dy = wall.end.y - wall.start.y;
                    const wallAngle = Math.atan2(dy, dx);
                    
                    // Find all features (doors and windows) on this wall
                    const featuresOnWall = [];
                    
                    room.doors.forEach((door, idx) => {
                        if (door.wallIndex === wallIndex) {
                            featuresOnWall.push({
                                type: 'door',
                                index: idx,
                                distanceFromLeft: door.distanceFromLeft || 0,
                                width: door.width / 12 // Convert inches to feet
                            });
                        }
                    });
                    
                    room.windows.forEach((win, idx) => {
                        if (win.wallIndex === wallIndex) {
                            featuresOnWall.push({
                                type: 'window',
                                index: idx,
                                distanceFromLeft: win.distanceFromLeft || 0,
                                width: win.width / 12 // Convert inches to feet
                            });
                        }
                    });
                    
                    

// Wall cuts (openings) on this wall - treated like a "feature" for dimensioning
if (wall.cuts && wall.cuts.length) {
    wall.cuts.forEach((cut, idx) => {
        const start = Number(cut.startDist ?? cut.start ?? cut.distanceFromLeft ?? 0);
        const end = Number(cut.endDist ?? cut.end ?? (start + (cut.width || 0)));
        const w = Math.max(0, end - start);
        if (w > 0.01) {
            featuresOnWall.push({
                type: 'cut',
                index: idx,
                distanceFromLeft: start,
                width: w // already feet
            });
        }
    });
}

// Missing walls (openings) on this wall - treated like a "feature" for dimensioning
if (wall.missingWalls && wall.missingWalls.length) {
    wall.missingWalls.forEach((missing, idx) => {
        const start = Number(missing.startDist ?? 0);
        const end = Number(missing.endDist ?? 0);
        const w = Math.max(0, end - start);
        if (w > 0.01) {
            featuresOnWall.push({
                type: 'missing',
                index: idx,
                distanceFromLeft: start,
                width: w // already feet
            });
        }
    });
}

                    if (featuresOnWall.length === 0) return;
                    
                    // Sort features by distance from left
                    featuresOnWall.sort((a, b) => a.distanceFromLeft - b.distanceFromLeft);
                    
                    // Calculate ALL dimension segments including features
                    const allSegments = [];
                    let currentPos = 0;
                    
                    featuresOnWall.forEach(feature => {
                        // distanceFromLeft is now the LEFT EDGE position
                        // feature.width in featuresOnWall is already in feet
                        const featureWidthFt = feature.width;
                        const featureStartEdge = feature.distanceFromLeft;
                        const featureEndEdge = feature.distanceFromLeft + featureWidthFt;
                        
                        // Distance from current position to start edge of feature
                        const distToFeature = featureStartEdge - currentPos;
                        if (distToFeature > 0.05) { // Only show if > 0.05 ft (about 1/2 inch)
                            allSegments.push({
                                start: currentPos,
                                end: featureStartEdge,
                                distance: distToFeature,
                                type: 'clear',
                                label: `${distToFeature.toFixed(2)}'`
                            });
                        }
                        
                        // The feature itself (door or window)
                        allSegments.push({
                            start: featureStartEdge,
                            end: featureEndEdge,
                            distance: featureWidthFt,
                            type: feature.type,
                            label: feature.type === 'door' ? `üö™ ${featureWidthFt.toFixed(2)}'` : 
                                   feature.type === 'window' ? `ü™ü ${featureWidthFt.toFixed(2)}'` :
                                   feature.type === 'missing' ? `üß± ${featureWidthFt.toFixed(2)}'` :
                                   `‚úÇÔ∏è ${featureWidthFt.toFixed(2)}'` // cut
                        });
                        
                        currentPos = featureEndEdge;
                    });
                    
                    // Distance from last feature to end of wall
                    const remainingDist = wallLength - currentPos;
                    if (remainingDist > 0.05) {
                        allSegments.push({
                            start: currentPos,
                            end: wallLength,
                            distance: remainingDist,
                            type: 'clear',
                            label: `${remainingDist.toFixed(2)}'`
                        });
                    }
                    
                    // Draw dimension lines for ALL segments
                    allSegments.forEach(segment => {
                        // Calculate positions along wall
                        const startPos = segment.start / wallLength;
                        const endPos = segment.end / wallLength;
                        
                        const x1 = wall.start.x + dx * startPos;
                        const y1 = wall.start.y + dy * startPos;
                        const x2 = wall.start.x + dx * endPos;
                        const y2 = wall.start.y + dy * endPos;
                        
                        // Different offset for features vs clear spaces
                        const offsetDist = segment.type === 'clear' ? 25 / state.zoom : 15 / state.zoom;
                        const perpAngle = wallAngle + Math.PI / 2;
                        const ox = Math.cos(perpAngle) * offsetDist;
                        const oy = Math.sin(perpAngle) * offsetDist;
                        
                        ctx.save();
                        
                        // Color based on segment type
                        const lineColor = segment.type === 'clear' ? '#FF6B6B' : '#4A90E2';
                        const textColor = segment.type === 'clear' ? '#D63031' : '#2E5C8A';
                        
                        // Draw dimension line
                        ctx.strokeStyle = lineColor;
                        ctx.lineWidth = segment.type === 'clear' ? 1.5 / state.zoom : 2 / state.zoom;
                        ctx.setLineDash([3 / state.zoom, 2 / state.zoom]);
                        ctx.beginPath();
                        ctx.moveTo(x1 + ox, y1 + oy);
                        ctx.lineTo(x2 + ox, y2 + oy);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Draw end ticks
                        const tickSize = 4 / state.zoom;
                        const tickAngle = wallAngle + Math.PI / 2;
                        
                        ctx.strokeStyle = lineColor;
                        ctx.lineWidth = 2 / state.zoom;
                        
                        // Tick at start
                        ctx.beginPath();
                        ctx.moveTo(x1 + ox + Math.cos(tickAngle) * tickSize, 
                                   y1 + oy + Math.sin(tickAngle) * tickSize);
                        ctx.lineTo(x1 + ox - Math.cos(tickAngle) * tickSize, 
                                   y1 + oy - Math.sin(tickAngle) * tickSize);
                        ctx.stroke();
                        
                        // Tick at end
                        ctx.beginPath();
                        ctx.moveTo(x2 + ox + Math.cos(tickAngle) * tickSize, 
                                   y2 + oy + Math.sin(tickAngle) * tickSize);
                        ctx.lineTo(x2 + ox - Math.cos(tickAngle) * tickSize, 
                                   y2 + oy - Math.sin(tickAngle) * tickSize);
                        ctx.stroke();
                        
                        // Draw dimension text
                        const midX = (x1 + x2) / 2 + ox;
                        const midY = (y1 + y2) / 2 + oy;
                        
                        ctx.translate(midX, midY);
                        
                        let textAngle = wallAngle;
                        if (Math.abs(wallAngle) > Math.PI / 2) {
                            textAngle = wallAngle + Math.PI;
                        }
                        ctx.rotate(textAngle);
                        
                        const fontSize = segment.type === 'clear' ? 9 / state.zoom : 10 / state.zoom;
                        ctx.font = `bold ${fontSize}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        // Background for text
                        const text = segment.label;
                        const textMetrics = ctx.measureText(text);
                        const textWidth = textMetrics.width;
                        const textHeight = fontSize * 1.2;
                        
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                        ctx.fillRect(-textWidth / 2 - 2 / state.zoom, -textHeight / 2, 
                                    textWidth + 4 / state.zoom, textHeight);
                        
                        // Border around text
                        ctx.strokeStyle = lineColor;
                        ctx.lineWidth = 0.5 / state.zoom;
                        ctx.strokeRect(-textWidth / 2 - 2 / state.zoom, -textHeight / 2, 
                                      textWidth + 4 / state.zoom, textHeight);
                        
                        ctx.fillStyle = textColor;
                        ctx.fillText(text, 0, 0);
                        
                        ctx.restore();
                    });
                });
            }
            
            // Draw doors and windows for all rooms (always visible)
            // Draw doors
            room.doors.forEach((door, index) => {
                    const w = door.width / 12 * 30 / 2; // Half width in pixels
                    
                    // Highlight if hovering
                    if (hoverDoorIndex === index && isCurrentRoom) {
                        ctx.save();
                        ctx.translate(door.x, door.y);
                        ctx.rotate((door.rotation || 0) * Math.PI / 180);
                        
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        ctx.fillRect(-w - 20 / state.zoom, -30 / state.zoom, w * 2 + 40 / state.zoom, 60 / state.zoom);
                        
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 5 / state.zoom;
                        ctx.strokeRect(-w - 20 / state.zoom, -30 / state.zoom, w * 2 + 40 / state.zoom, 60 / state.zoom);
                        
                        ctx.restore();
                    }
                    
                    ctx.save();
                    ctx.translate(door.x, door.y);
                    ctx.rotate((door.rotation || 0) * Math.PI / 180);
                    
                    // Draw standard architectural door symbol
                    const doorWidth = w * 2; // Full door width in pixels
                    const hingeSide = door.hinge || 'right'; // Default to right hinge
                    const swingDir = door.swingDirection || 'in'; // Default to swing in
                    
                    // 1. Door opening (gap in wall) - 36" wide
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1 / state.zoom;
                    ctx.beginPath();
                    ctx.moveTo(-w, 0); // Left edge of opening
                    ctx.lineTo(w, 0);  // Right edge of opening
                    ctx.stroke();
                    
                    // 2. Hinge point and door panel
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 2 / state.zoom;
                    ctx.beginPath();
                    
                    const openAngle = Math.PI / 4; // 45¬∞ in radians
                    
                    // Four combinations of hinge side and swing direction
                    if (hingeSide === 'right' && swingDir === 'in') {
                        // Hinge on RIGHT, swings INTO room (positive Y)
                        ctx.moveTo(w, 0); // Hinge at right edge
                        const doorAngle = Math.PI - openAngle; // 135¬∞
                        const doorEndX = w + doorWidth * Math.cos(doorAngle);
                        const doorEndY = doorWidth * Math.sin(doorAngle);
                        ctx.lineTo(doorEndX, doorEndY);
                        ctx.stroke();
                        
                        ctx.strokeStyle = '#654321';
                        ctx.lineWidth = 1 / state.zoom;
                        ctx.beginPath();
                        ctx.arc(w, 0, doorWidth, Math.PI, Math.PI - openAngle, true);
                        ctx.stroke();
                        
                    } else if (hingeSide === 'right' && swingDir === 'out') {
                        // Hinge on RIGHT, swings OUT of room (negative Y)
                        ctx.moveTo(w, 0); // Hinge at right edge
                        const doorAngle = Math.PI + openAngle; // 225¬∞
                        const doorEndX = w + doorWidth * Math.cos(doorAngle);
                        const doorEndY = doorWidth * Math.sin(doorAngle);
                        ctx.lineTo(doorEndX, doorEndY);
                        ctx.stroke();
                        
                        ctx.strokeStyle = '#654321';
                        ctx.lineWidth = 1 / state.zoom;
                        ctx.beginPath();
                        ctx.arc(w, 0, doorWidth, Math.PI, Math.PI + openAngle, false);
                        ctx.stroke();
                        
                    } else if (hingeSide === 'left' && swingDir === 'in') {
                        // Hinge on LEFT, swings INTO room (positive Y)
                        ctx.moveTo(-w, 0); // Hinge at left edge
                        const doorAngle = openAngle; // 45¬∞
                        const doorEndX = -w + doorWidth * Math.cos(doorAngle);
                        const doorEndY = doorWidth * Math.sin(doorAngle);
                        ctx.lineTo(doorEndX, doorEndY);
                        ctx.stroke();
                        
                        ctx.strokeStyle = '#654321';
                        ctx.lineWidth = 1 / state.zoom;
                        ctx.beginPath();
                        ctx.arc(-w, 0, doorWidth, 0, openAngle, false);
                        ctx.stroke();
                        
                    } else { // left + out
                        // Hinge on LEFT, swings OUT of room (negative Y)
                        ctx.moveTo(-w, 0); // Hinge at left edge
                        const doorAngle = -openAngle; // -45¬∞ (or 315¬∞)
                        const doorEndX = -w + doorWidth * Math.cos(doorAngle);
                        const doorEndY = doorWidth * Math.sin(doorAngle);
                        ctx.lineTo(doorEndX, doorEndY);
                        ctx.stroke();
                        
                        ctx.strokeStyle = '#654321';
                        ctx.lineWidth = 1 / state.zoom;
                        ctx.beginPath();
                        ctx.arc(-w, 0, doorWidth, 0, -openAngle, true);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                    
                    if (hoverDoorIndex === index && isCurrentRoom) {
                        ctx.font = `bold ${16 / state.zoom}px Arial`;
                        ctx.fillStyle = '#FF0000';
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 3 / state.zoom;
                        ctx.strokeText('CLICK TO EDIT', door.x, door.y + 45 / state.zoom);
                        ctx.fillText('CLICK TO EDIT', door.x, door.y + 45 / state.zoom);
                    }
                });
                
                // Draw windows (three parallel lines)
                room.windows.forEach((win, index) => {
                    const w = win.width / 12 * 30 / 2; // Half width in pixels
                    
                    if (hoverWindowIndex === index && isCurrentRoom) {
                        ctx.save();
                        ctx.translate(win.x, win.y);
                        ctx.rotate((win.rotation || 0) * Math.PI / 180);
                        
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        ctx.fillRect(-w - 20 / state.zoom, -30 / state.zoom, w * 2 + 40 / state.zoom, 60 / state.zoom);
                        
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 5 / state.zoom;
                        ctx.strokeRect(-w - 20 / state.zoom, -30 / state.zoom, w * 2 + 40 / state.zoom, 60 / state.zoom);
                        
                        ctx.restore();
                    }
                    
                    ctx.save();
                    ctx.translate(win.x, win.y);
                    ctx.rotate((win.rotation || 0) * Math.PI / 180);
                    
                    // Draw standard architectural window symbol (three parallel lines)
                    ctx.strokeStyle = '#4682B4';
                    ctx.lineWidth = 2 / state.zoom;
                    
                    // Outer line 1
                    ctx.beginPath();
                    ctx.moveTo(-w, -6 / state.zoom);
                    ctx.lineTo(w, -6 / state.zoom);
                    ctx.stroke();
                    
                    // Middle line
                    ctx.beginPath();
                    ctx.moveTo(-w, 0);
                    ctx.lineTo(w, 0);
                    ctx.stroke();
                    
                    // Outer line 2
                    ctx.beginPath();
                    ctx.moveTo(-w, 6 / state.zoom);
                    ctx.lineTo(w, 6 / state.zoom);
                    ctx.stroke();
                    
                    ctx.restore();
                    
                    if (hoverWindowIndex === index && isCurrentRoom) {
                        ctx.font = `bold ${16 / state.zoom}px Arial`;
                        ctx.fillStyle = '#FF0000';
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 3 / state.zoom;
                        ctx.strokeText('CLICK TO EDIT', win.x, win.y + 45 / state.zoom);
                        ctx.fillText('CLICK TO EDIT', win.x, win.y + 45 / state.zoom);
                    }
                });
            
            ctx.restore();
        }

        function redraw2D() {
            // Don't redraw 2D canvas when in 3D mode
            if (state.currentView === '3d') {
                console.log('redraw2D called but in 3D mode - skipping');
                return;
            }
            
            ctx.clearRect(0, 0, canvas2D.width, canvas2D.height);
            ctx.save();
            ctx.translate(state.panX, state.panY);
            ctx.scale(state.zoom, state.zoom);
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1 / state.zoom;
            for (let x = 0; x < canvas2D.width / state.zoom; x += 30) {
                ctx.beginPath();
                ctx.moveTo(x - state.panX / state.zoom, -state.panY / state.zoom);
                ctx.lineTo(x - state.panX / state.zoom, (canvas2D.height - state.panY) / state.zoom);
                ctx.stroke();
            }
            for (let y = 0; y < canvas2D.height / state.zoom; y += 30) {
                ctx.beginPath();
                ctx.moveTo(-state.panX / state.zoom, y - state.panY / state.zoom);
                ctx.lineTo((canvas2D.width - state.panX) / state.zoom, y - state.panY / state.zoom);
                ctx.stroke();
            }
            
            if (state.showAllRooms) {
                // Draw all rooms at their positions
                state.rooms.forEach((room, idx) => {
                    const offsetX = (room.positionX || 0) * 30;
                    const offsetZ = (room.positionZ || 0) * 30;
                    const isCurrentRoom = idx === state.currentRoomIndex;
                    drawSingleRoom(room, offsetX, offsetZ, isCurrentRoom);
                });
            } else {
                // Draw only current room
                const room = getCurrentRoom();
                if (room) {
                    drawSingleRoom(room, 0, 0, true);
                }
            }
            
            // Draw wall hover effects for current room only
            if (state.wallSelectionMode && !state.showAllRooms) {
                const room = getCurrentRoom();
                if (room) {
                    room.walls.forEach((wall, index) => {
                        if (index === state.hoveredWall) {
                            ctx.strokeStyle = '#00FF00';
                            ctx.lineWidth = 10 / state.zoom;
                            ctx.beginPath();
                            ctx.moveTo(wall.start.x, wall.start.y);
                            ctx.lineTo(wall.end.x, wall.end.y);
                            ctx.stroke();
                        }
                    });
                    
                    if (hoverClickPoint) {
                        ctx.fillStyle = 'gold';
                        ctx.beginPath();
                        ctx.arc(hoverClickPoint.x, hoverClickPoint.y, 8 / state.zoom, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.strokeStyle = 'red';
                        ctx.lineWidth = 3 / state.zoom;
                        ctx.beginPath();
                        ctx.moveTo(hoverClickPoint.x - 15 / state.zoom, hoverClickPoint.y);
                        ctx.lineTo(hoverClickPoint.x + 15 / state.zoom, hoverClickPoint.y);
                        ctx.moveTo(hoverClickPoint.x, hoverClickPoint.y - 15 / state.zoom);
                        ctx.lineTo(hoverClickPoint.x, hoverClickPoint.y + 15 / state.zoom);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw snap indicators when dragging and snapped
            if (state.draggingRoom !== null && state.lastSnapped && state.showAllRooms) {
                const room = state.rooms[state.draggingRoom];
                if (room.floorPoints.length >= 3) {
                    // Calculate room bounds
                    let minX = Infinity, maxX = -Infinity;
                    let minZ = Infinity, maxZ = -Infinity;
                    
                    room.floorPoints.forEach(p => {
                        minX = Math.min(minX, p.x);
                        maxX = Math.max(maxX, p.x);
                        minZ = Math.min(minZ, p.y);
                        maxZ = Math.max(maxZ, p.y);
                    });
                    
                    const offsetX = (room.positionX || 0) * 30;
                    const offsetZ = (room.positionZ || 0) * 30;
                    
                    // Draw bright green lines at room edges to show snap
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 4 / state.zoom;
                    ctx.setLineDash([10 / state.zoom, 5 / state.zoom]);
                    
                    // Draw box around room
                    ctx.beginPath();
                    ctx.rect(minX + offsetX, minZ + offsetZ, maxX - minX, maxZ - minZ);
                    ctx.stroke();
                    
                    ctx.setLineDash([]);
                    
                    // Draw "SNAPPED" text
                    ctx.save();
                    ctx.font = `bold ${16 / state.zoom}px Arial`;
                    ctx.fillStyle = '#00FF00';
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 3 / state.zoom;
                    ctx.textAlign = 'center';
                    const centerX = (minX + maxX) / 2 + offsetX;
                    const centerY = (minZ + maxZ) / 2 + offsetZ;
                    const snapText = state.snapType || '‚ö° SNAPPED';
                    ctx.strokeText(snapText, centerX, centerY);
                    ctx.fillText(snapText, centerX, centerY);
                    ctx.restore();
                }
            }
            
            ctx.restore();
        }

        let isRendering3D = false; // Prevent re-entrant calls
        const SHOW_3D_DIMENSIONS = false; // keep 3D clean: no wall/door/window dimension labels
        let render3DCallCount = 0;
        
        function render3D() {
            render3DCallCount++;
            const callId = render3DCallCount;
            
            console.log('=== render3D called === (Call #' + callId + ')');
            console.log('Call stack:', new Error().stack.split('\n').slice(2, 5).join('\n'));
            console.log('Current view:', state.currentView);
            console.log('Scene children before clear:', scene.children.length);
            console.log('isRendering3D flag:', isRendering3D);
            
            // Prevent re-entrant calls
            if (isRendering3D) {
                console.log('WARNING: render3D already in progress, skipping this call (Call #' + callId + ')');
                return;
            }
            
            // Only render if we're actually in 3D mode
            if (state.currentView !== '3d') {
                console.log('WARNING: render3D called but not in 3D mode, skipping (Call #' + callId + ')');
                return;
            }
            
            // Check if scene and renderer exist
            if (!scene || !renderer) {
                console.error('ERROR: Scene or renderer not initialized! (Call #' + callId + ')');
                return;
            }
            
            isRendering3D = true;
            
            try {
                console.log('Clearing scene objects... (Call #' + callId + ')');
                while(scene.children.length > 3) scene.remove(scene.children[3]);
                console.log('Scene cleared, now has', scene.children.length, 'children (Call #' + callId + ')');
                
                // Calculate total width needed for all rooms to adjust camera
                const totalRooms = state.rooms.filter(r => r.floorPoints.length >= 3).length;
                const roomSpacing = 30;
            
            console.log('Rendering 3D view, total rooms:', totalRooms);
            
            if (totalRooms === 0) {
                console.log('WARNING: No rooms with floor points to render');
                return;
            }
            
            const renderedWalls = new Set();
            
            state.rooms.forEach((room, idx) => {
                if (room.floorPoints.length < 3) return;
                
                console.log(`Room ${idx}: ${room.name}, Doors: ${room.doors.length}, Windows: ${room.windows.length}, Position: (${room.positionX}, ${room.positionZ})`);
                
                // Use explicit position if set, otherwise use default spacing
                // Need to check for undefined/null, not falsy (because 0 is valid!)
                const offsetX = (room.positionX !== undefined && room.positionX !== null) ? room.positionX : (idx * roomSpacing);
                const offsetZ = (room.positionZ !== undefined && room.positionZ !== null) ? room.positionZ : 0;
                
                console.log(`  üìç Calculated offsets: X=${offsetX}, Z=${offsetZ} (roomSpacing=${roomSpacing})`);
                console.log(`  üìê Floor points: ${room.floorPoints.length} points`);
                
                // Floor and ceiling removed - showing only walls
                
                // Create shape for reference (used for dimensions later)
                const shape = new THREE.Shape();
                shape.moveTo(-(room.floorPoints[0].x / 30 + offsetX), -(room.floorPoints[0].y / 30 + offsetZ));
                room.floorPoints.forEach((p, i) => {
                    if (i > 0) shape.lineTo(-(p.x / 30 + offsetX), -(p.y / 30 + offsetZ));
                });
                shape.closePath();
                
                // Walls - check for cuts and render accordingly
                room.walls.forEach((wall, wallIdx) => {
                    // Skip duplicate walls
                    const wKey = `${Math.round(wall.start.x/10)*10},${Math.round(wall.start.y/10)*10}-${Math.round(wall.end.x/10)*10},${Math.round(wall.end.y/10)*10}`;
                    const wKeyRev = `${Math.round(wall.end.x/10)*10},${Math.round(wall.end.y/10)*10}-${Math.round(wall.start.x/10)*10},${Math.round(wall.start.y/10)*10}`;
                    if (renderedWalls.has(wKey) || renderedWalls.has(wKeyRev)) return;
                    renderedWalls.add(wKey);
                    
                    const len = Math.sqrt((wall.end.x - wall.start.x)**2 + (wall.end.y - wall.start.y)**2) / 30;
                    const wallThickness = (room.wallThickness || 4) / 12 * 0.3048; // Convert inches to meters
                    
                    const mx = -((wall.start.x + wall.end.x) / 2 / 30 + offsetX);
                    const mz = -((wall.start.y + wall.end.y) / 2 / 30 + offsetZ);
                    const angle = Math.atan2(wall.end.y - wall.start.y, wall.end.x - wall.start.x);
                    
                    // Check if wall has cuts
                    const hasCuts = (wall.cuts && wall.cuts.length > 0) || (wall.missingWalls && wall.missingWalls.length > 0);
                    
                    console.log(`  Wall ${wallIdx} (${wall.name}): hasCuts=${hasCuts}, cuts=${wall.cuts ? wall.cuts.length : 0}`);
                    
                    if (hasCuts) {
                        // Wall has cuts or missing walls - render as separate segments with gaps
                        const sortedCuts = getWallOpenings(wall);
                        
                        console.log(`  Wall ${wallIdx} HAS CUTS - Length: ${wall.length} ft`);
                        console.log(`  Cuts:`, sortedCuts);
                        
                        // Calculate all segments (wall pieces and gaps)
                        const segments = [];
                        let pos = 0;
                        sortedCuts.forEach(cut => {
                            if (cut.startDist > pos) segments.push({ type: 'wall', start: pos, end: cut.startDist });
                            segments.push({ 
                                type: 'gap', 
                                start: cut.startDist, 
                                end: cut.endDist,
                                height: cut.height || room.ceilingHeight,
                                floorDistance: cut.floorDistance || 0
                            });
                            pos = cut.endDist;
                        });
                        if (pos < parseFloat(wall.length)) segments.push({ type: 'wall', start: pos, end: parseFloat(wall.length) });
                        
                        console.log(`  Segments:`, segments);
                        let totalLength = segments.reduce((sum, s) => sum + (s.end - s.start), 0);
                        console.log(`  Total segment length: ${totalLength.toFixed(2)} ft (should be ${wall.length} ft)`);
                        
                        // Render each segment
                        segments.forEach((seg, i) => {
                            if (seg.type === 'wall') {
                                // Render wall segment without extensions
                                const segStart = seg.start;
                                const segEnd = seg.end;
                                
                                // Calculate segment endpoints in pixels
                                const t1 = segStart / parseFloat(wall.length);
                                const t2 = segEnd / parseFloat(wall.length);
                                
                                const x1 = wall.start.x + (wall.end.x - wall.start.x) * t1;
                                const y1 = wall.start.y + (wall.end.y - wall.start.y) * t1;
                                const x2 = wall.start.x + (wall.end.x - wall.start.x) * t2;
                                const y2 = wall.start.y + (wall.end.y - wall.start.y) * t2;
                                
                                // Segment center and length in pixels
                                const segCenterX = (x1 + x2) / 2;
                                const segCenterY = (y1 + y2) / 2;
                                const segPixelLen = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
                                const segLenFeet = segPixelLen / 30;  // Use feet like normal walls
                                
                                // Convert to 3D coordinates
                                const segX = -(segCenterX / 30 + offsetX);
                                const segZ = -(segCenterY / 30 + offsetZ);
                                
                                console.log(`    Segment ${i}: wall ${seg.start.toFixed(1)}-${seg.end.toFixed(1)} ft, pixels (${x1.toFixed(0)}, ${y1.toFixed(0)}) to (${x2.toFixed(0)}, ${y2.toFixed(0)}), 3D pos (${segX.toFixed(2)}, ${segZ.toFixed(2)})`);
                            
                                // Render wall segment (using feet)
                                const segGeom = new THREE.BoxGeometry(segLenFeet, room.ceilingHeight * 0.3048, wallThickness);
                                const segMat = new THREE.MeshLambertMaterial({ color: 0xF5E6D3 }); // Warm beige
                                const segMesh = new THREE.Mesh(segGeom, segMat);
                                segMesh.position.set(segX, room.ceilingHeight * 0.3048 / 2, segZ);
                                segMesh.rotation.y = -angle;
                                segMesh.castShadow = true;
                                segMesh.receiveShadow = true;
                                scene.add(segMesh);
                                
                                if (SHOW_3D_DIMENSIONS) {
                                
                                // Add dimension label
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                canvas.width = 256;
                                canvas.height = 64;
                                ctx.fillStyle = '#FFFFFF';
                                ctx.fillRect(0, 0, 256, 64);
                                ctx.font = 'bold 32px Arial';
                                ctx.fillStyle = '#000000';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(`${(seg.end - seg.start).toFixed(1)} ft`, 128, 32);
                                
                                const tex = new THREE.CanvasTexture(canvas);
                                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex }));
                                const perpX = -Math.sin(angle) * 0.5;
                                const perpZ = Math.cos(angle) * 0.5;
                                sprite.position.set(segX + perpX, room.ceilingHeight * 0.3048 / 2, segZ + perpZ);
                                sprite.scale.set(2, 0.5, 1);
                                scene.add(sprite);
                                
                                }
                            } else if (seg.type === 'gap') {
                                try {
                                    // Render gap with bottom wall, opening, and top wall
                                    const segStart = seg.start;
                                    const segEnd = seg.end;
                                    const openingHeight = seg.height || 3;
                                    const floorDist = seg.floorDistance || 0;
                                    
                                    // Calculate segment endpoints
                                    const t1 = segStart / parseFloat(wall.length);
                                    const t2 = segEnd / parseFloat(wall.length);
                                    
                                    const x1 = wall.start.x + (wall.end.x - wall.start.x) * t1;
                                    const y1 = wall.start.y + (wall.end.y - wall.start.y) * t1;
                                    const x2 = wall.start.x + (wall.end.x - wall.start.x) * t2;
                                    const y2 = wall.start.y + (wall.end.y - wall.start.y) * t2;
                                    
                                    const segCenterX = (x1 + x2) / 2;
                                    const segCenterY = (y1 + y2) / 2;
                                    const segPixelLen = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
                                    const segLenFeet = segPixelLen / 30;
                                    
                                    const segX = -(segCenterX / 30 + offsetX);
                                    const segZ = -(segCenterY / 30 + offsetZ);
                                    
                                    const ceilingHeightFeet = room.ceilingHeight || 8;
                                    
                                    console.log(`    Segment ${i}: GAP ${seg.start.toFixed(1)}-${seg.end.toFixed(1)} ft, height: ${openingHeight} ft, floor dist: ${floorDist} ft`);
                                    
                                    // 1. Bottom wall (floor to opening start)
                                    if (floorDist > 0.01) {
                                        const bottomHeight = floorDist * 0.3048;
                                        const bottomY = bottomHeight / 2;
                                        const bottomGeom = new THREE.BoxGeometry(segLenFeet, bottomHeight, wallThickness);
                                        const bottomMat = new THREE.MeshLambertMaterial({ color: 0xF5E6D3 });
                                        const bottomMesh = new THREE.Mesh(bottomGeom, bottomMat);
                                        bottomMesh.position.set(segX, bottomY, segZ);
                                        bottomMesh.rotation.y = -angle;
                                        bottomMesh.castShadow = true;
                                        bottomMesh.receiveShadow = true;
                                        scene.add(bottomMesh);
                                        console.log(`      Bottom wall: floor to ${floorDist.toFixed(1)} ft`);
                                    }
                                    
                                    // 2. GAP (no wall)
                                    console.log(`      GAP: ${floorDist.toFixed(1)} ft to ${(floorDist + openingHeight).toFixed(1)} ft`);
                                    
                                    // 3. Top wall (opening end to ceiling)
                                    const topStart = floorDist + openingHeight;
                                    if (topStart < ceilingHeightFeet - 0.01) {
                                        const topHeight = (ceilingHeightFeet - topStart) * 0.3048;
                                        const topY = (topStart * 0.3048) + (topHeight / 2);
                                        const topGeom = new THREE.BoxGeometry(segLenFeet, topHeight, wallThickness);
                                        const topMat = new THREE.MeshLambertMaterial({ color: 0xF5E6D3 });
                                        const topMesh = new THREE.Mesh(topGeom, topMat);
                                        topMesh.position.set(segX, topY, segZ);
                                        topMesh.rotation.y = -angle;
                                        topMesh.castShadow = true;
                                        topMesh.receiveShadow = true;
                                        scene.add(topMesh);
                                        console.log(`      Top wall: ${topStart.toFixed(1)} ft to ${ceilingHeightFeet} ft`);
                                    }
                                    
                                    if (SHOW_3D_DIMENSIONS) {
                                        const canvas = document.createElement('canvas');
                                        const ctx = canvas.getContext('2d');
                                        canvas.width = 256;
                                        canvas.height = 64;
                                        ctx.fillStyle = '#FF0000';
                                        ctx.fillRect(0, 0, 256, 64);
                                        ctx.font = 'bold 32px Arial';
                                        ctx.fillStyle = '#FFFFFF';
                                        ctx.textAlign = 'center';
                                        ctx.textBaseline = 'middle';
                                        ctx.fillText(`OPENING ${(seg.end - seg.start).toFixed(1)} ft`, 128, 32);
                                        const tex = new THREE.CanvasTexture(canvas);
                                        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex }));
                                        const perpX = -Math.sin(angle) * 0.5;
                                        const perpZ = Math.cos(angle) * 0.5;
                                        const midHeight = (floorDist + openingHeight / 2) * 0.3048;
                                        sprite.position.set(segX + perpX, midHeight, segZ + perpZ);
                                        sprite.scale.set(2, 0.5, 1);
                                        scene.add(sprite);
                                    }
                                } catch (error) {
                                    console.error(`Error rendering gap segment:`, error);
                                }
                            }
                        });
                    } else {
                        // Normal wall without cuts - render as single piece
                        // Add small extension to close corner gaps (2 inches = 0.167 ft)
                        const extension = wallThickness * 2.0; // overlap ends by ~2x thickness to hide corner seams
                        const extendedLen = len + extension;
                        
                        const wallGeom = new THREE.BoxGeometry(extendedLen, room.ceilingHeight * 0.3048, wallThickness);
                        const wallMat = new THREE.MeshLambertMaterial({ 
                            color: 0xF5E6D3, // Warm beige
                            transparent: false,
                            opacity: 1.0
                        });
                        const wallMesh = new THREE.Mesh(wallGeom, wallMat);
                        
                        wallMesh.position.set(mx, room.ceilingHeight * 0.3048 / 2, mz);
                        wallMesh.rotation.y = -angle;
                        wallMesh.castShadow = true;
                        wallMesh.receiveShadow = true;
                        scene.add(wallMesh);
                        
                        console.log(`  Wall ${wallIdx}: color=BEIGE, thickness=${wallThickness}m, position=(${mx}, ${room.ceilingHeight * 0.3048 / 2}, ${mz}), extended by ${extension.toFixed(3)}m`);
                        
                        if (SHOW_3D_DIMENSIONS) {
                        // Add dimension label to wall
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = 256;
                        canvas.height = 64;
                        
                        context.fillStyle = '#ffffff';
                        context.fillRect(0, 0, canvas.width, canvas.height);
                        context.font = 'bold 32px Arial';
                        context.fillStyle = '#000000';
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillText(`${wall.length} ft`, canvas.width / 2, canvas.height / 2);
                        
                        const texture = new THREE.CanvasTexture(canvas);
                        const labelMaterial = new THREE.SpriteMaterial({ map: texture });
                        const label = new THREE.Sprite(labelMaterial);
                        label.position.set(mx, room.ceilingHeight * 0.3048 / 2, mz);
                        label.scale.set(2, 0.5, 1);
                        scene.add(label);
                        }
                    }
                });

// Corner join posts (hide tiny gaps where wall segments meet)
;

                
                // Ceiling removed - showing only walls
                
                // Room name labels removed per user request
                // Ceiling height labels removed per user request
                
                // Doors - Make them VERY visible
                console.log(`Rendering ${room.doors.length} doors for room ${idx}`);
                room.doors.forEach((door, doorIdx) => {
                    console.log(`  Door ${doorIdx}: x=${door.x}, y=${door.y}, width=${door.width}, rotation=${door.rotation}`);
                    
                    const doorWidth = door.width / 12 * 0.3048;
                    const doorHeightInches = door.height || 80; // Default to 80 inches (6'8") if not set
                    const doorHeight = doorHeightInches / 12 * 0.3048; // Convert inches to meters
                    const doorThickness = 0.15; // Make thicker
                    const doorGeom = new THREE.BoxGeometry(doorWidth, doorHeight, doorThickness);
                    const doorMat = new THREE.MeshLambertMaterial({ 
                        color: 0x654321, // Darker brown
                        emissive: 0x442200
                    });
                    const doorMesh = new THREE.Mesh(doorGeom, doorMat);
                    doorMesh.position.set(-(door.x / 30 + offsetX), doorHeight / 2, -(door.y / 30 + offsetZ));
                    doorMesh.rotation.y = -(door.rotation || 0) * Math.PI / 180;
                    doorMesh.castShadow = true;
                    scene.add(doorMesh);
                    console.log(`  Door mesh position: (${doorMesh.position.x}, ${doorMesh.position.y}, ${doorMesh.position.z})`);
                    
                    // Add bright door frame for high visibility
                    const frameGeom = new THREE.BoxGeometry(doorWidth + 0.15, doorHeight + 0.15, 0.08);
                    const frameMat = new THREE.MeshLambertMaterial({ 
                        color: 0xFF6B35, // Bright orange frame
                        emissive: 0xFF6B35
                    });
                    const frame = new THREE.Mesh(frameGeom, frameMat);
                    frame.position.copy(doorMesh.position);
                    frame.position.z += doorThickness / 2 + 0.04;
                    frame.rotation.y = doorMesh.rotation.y;
                    scene.add(frame);
                });
                
                // Windows
                console.log(`Rendering ${room.windows.length} windows for room ${idx}`);
                room.windows.forEach((win, winIdx) => {
                    console.log(`  Window ${winIdx}: x=${win.x}, y=${win.y}, width=${win.width}, height=${win.height}`);
                    
                    const winWidth = win.width / 12 * 0.3048; // Convert inches to meters
                    const winHeightInches = win.height || 36; // Default 36" if not set
                    const winHeight = winHeightInches / 12 * 0.3048; // Convert inches to meters
                    const heightFromFloor = (win.heightFromFloor || 3.0) * 0.3048; // Convert feet to meters
                    const winThickness = 0.12;
                    
                    const winGeom = new THREE.BoxGeometry(winWidth, winHeight, winThickness);
                    const winMat = new THREE.MeshLambertMaterial({ 
                        color: 0x87CEEB, // Sky blue for glass
                        transparent: true, 
                        opacity: 0.6,
                        emissive: 0x4A90E2
                    });
                    const winMesh = new THREE.Mesh(winGeom, winMat);
                    winMesh.position.set(-(win.x / 30 + offsetX), heightFromFloor + winHeight / 2, -(win.y / 30 + offsetZ));
                    winMesh.rotation.y = -(win.rotation || 0) * Math.PI / 180;
                    scene.add(winMesh);
                    console.log(`  Window mesh position: (${winMesh.position.x}, ${winMesh.position.y}, ${winMesh.position.z})`);
                    
                    // Add white window frame
                    const frameGeom = new THREE.BoxGeometry(winWidth + 0.15, winHeight + 0.15, 0.06);
                    const frameMat = new THREE.MeshLambertMaterial({ 
                        color: 0xFFFFFF, // White frame
                        emissive: 0xCCCCCC
                    });
                    const frame = new THREE.Mesh(frameGeom, frameMat);
                    frame.position.copy(winMesh.position);
                    frame.position.z += winThickness / 2 + 0.03;
                    frame.rotation.y = winMesh.rotation.y;
                    scene.add(frame);
                });
                
                // Room label boxes removed per user request
            });
            
            console.log('Camera position:', camera.position.x, camera.position.y, camera.position.z);
            console.log('About to render scene (Call #' + callId + ')...');
            console.log('About to render scene (Call #' + callId + ')...');
            console.log('Final scene children count:', scene.children.length);
            renderer.render(scene, camera);
            console.log('3D render complete (Call #' + callId + '), scene has', scene.children.length, 'children');
            
            } catch (error) {
                console.error('ERROR in render3D (Call #' + callId + '):', error);
                console.error('Stack:', error.stack);
            } finally {
                isRendering3D = false;
                console.log('=== render3D complete, flag reset (Call #' + callId + ') ===');
            }
        }

        // Note: This function is disabled - the animate() loop inside init3D() handles all 3D rendering
        // Keeping this here for reference only
        function animate3D() {
            // DISABLED - removed to prevent conflicts with init3D's animate() loop
            // The animate() function inside init3D() already handles all rendering
            console.log('animate3D() called but disabled - init3D animate() loop handles rendering');
        }

        function updateStats() {
            const room = getCurrentRoom();
            if (!room) return;
            
            let area = 0;
            if (room.floorPoints.length >= 3) {
                for (let i = 0; i < room.floorPoints.length; i++) {
                    const j = (i + 1) % room.floorPoints.length;
                    area += room.floorPoints[i].x * room.floorPoints[j].y;
                    area -= room.floorPoints[j].x * room.floorPoints[i].y;
                }
                area = Math.abs(area / 2) / 900;
            }
            
            const perimeter = room.walls.reduce((s, w) => s + parseFloat(w.length), 0);
            
            document.getElementById('statArea').textContent = area.toFixed(1) + ' sq ft';
            document.getElementById('statPerimeter').textContent = perimeter.toFixed(1) + ' ft';
            document.getElementById('statDoors').textContent = room.doors.length;
            document.getElementById('statWindows').textContent = room.windows.length;
        }

        function saveProject() {
            showFilenameModal('save');
        }
        
        function exportReport() {
            showFilenameModal('export');
        }
        
        function exportXactimateCSV() {
            showFilenameModal('xactimate-csv');
        }
        
        function exportXactimateReport() {
            showFilenameModal('xactimate-report');
        }
        
        function exportForExcel() {
            showFilenameModal('excel');
        }
        
        function toggleExportMenu() {
            const menu = document.getElementById('exportMenu');
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
        }
        
        // Close export menu when clicking outside
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('exportMenu');
            const btn = document.getElementById('exportBtn');
            if (menu && btn && !menu.contains(e.target) && !btn.contains(e.target)) {
                menu.style.display = 'none';
            }
        });
        
        // Filename Modal Functions
        let filenameAction = null;
        
        function showFilenameModal(action) {
            filenameAction = action;
            
            const modal = document.getElementById('filenameModal');
            const input = document.getElementById('filenameInput');
            const title = document.getElementById('filenameModalTitle');
            const confirmBtn = document.getElementById('filenameConfirmBtn');
            
            if (action === 'save') {
                title.textContent = 'üíæ Save Project';
                confirmBtn.textContent = 'Save';
            } else if (action === 'export') {
                title.textContent = 'üìÑ Export Report';
                confirmBtn.textContent = 'Export';
            } else if (action === 'xactimate-csv') {
                title.textContent = 'üìä Export Xactimate CSV';
                confirmBtn.textContent = 'Export CSV';
            } else if (action === 'xactimate-report') {
                title.textContent = 'üìã Export Xactimate Report';
                confirmBtn.textContent = 'Export Report';
            } else if (action === 'excel') {
                title.textContent = 'üìä Export for Excel';
                confirmBtn.textContent = 'Export Excel File';
            }
            
            // Pre-fill with current project name
            input.value = state.projectName;
            
            modal.style.display = 'flex';
            
            // Focus and select input
            setTimeout(() => {
                input.focus();
                input.select();
            }, 100);
            
            // Close export menu
            const exportMenu = document.getElementById('exportMenu');
            if (exportMenu) exportMenu.style.display = 'none';
        }
        
        function confirmFilename() {
            const input = document.getElementById('filenameInput');
            const filename = input.value.trim();
            
            if (!filename) {
                showToast('‚ùå Please enter a filename');
                return;
            }
            
            // Clean filename (remove invalid characters)
            const cleanFilename = filename.replace(/[<>:"/\\|?*]/g, '-');
            
            // Update project name
            state.projectName = cleanFilename;
            updateProjectNameDisplay();
            
            // Close modal
            document.getElementById('filenameModal').style.display = 'none';
            
            // Perform the action
            if (filenameAction === 'save') {
                performSave(cleanFilename);
            } else if (filenameAction === 'export') {
                performExport(cleanFilename);
            } else if (filenameAction === 'xactimate-csv') {
                performXactimateCSV(cleanFilename);
            } else if (filenameAction === 'xactimate-report') {
                performXactimateReport(cleanFilename);
            } else if (filenameAction === 'excel') {
                performExcelExport(cleanFilename);
            }
            
            filenameAction = null;
        }
        
        function cancelFilename() {
            document.getElementById('filenameModal').style.display = 'none';
            filenameAction = null;
        }
        
        function performSave(filename) {
            const data = {
                projectName: filename,
                rooms: state.rooms,
                savedDate: new Date().toISOString()
            };
            const jsonString = JSON.stringify(data, null, 2);
            
            // Save to localStorage
            try {
                const savedProjects = JSON.parse(localStorage.getItem('cochran_saved_projects') || '{}');
                savedProjects[filename] = data;
                localStorage.setItem('cochran_saved_projects', JSON.stringify(savedProjects));
                
                // Update current project name
                state.projectName = filename;
                updateProjectNameDisplay();
                
                showToast(`‚úì "${filename}" saved to browser storage!`);
                
                // On iPad: Also create downloadable text file
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                             (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                
                if (isIOS) {
                    // Open data in new tab - Safari can save from there
                    const dataUrl = 'data:application/json;charset=utf-8,' + encodeURIComponent(jsonString);
                    const newTab = window.open(dataUrl, '_blank');
                    if (newTab) {
                        showToast(`‚úì Saved! File opened in new tab - tap Share ‚Üí Save to Files`);
                    } else {
                        // Fallback: copy to clipboard
                        navigator.clipboard.writeText(jsonString).then(() => {
                            showToast(`‚úì Saved! Also copied to clipboard - paste into Notes`);
                        });
                    }
                } else {
                    // Desktop: Download file
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${filename}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showToast(`‚úì Saved & downloaded "${filename}.json"`);
                }
            } catch (error) {
                showToast(`‚ùå Save failed: ${error.message}`);
                console.error('Save error:', error);
            }
        }
        
        function copyToClipboardFallback(data, filename) {
            // Fallback: Copy to clipboard
            navigator.clipboard.writeText(data).then(() => {
                showToast(`‚úì Project data copied to clipboard! Paste into Notes app and save as "${filename}.json"`);
            }).catch(() => {
                // Last resort: Show in alert
                showToast(`‚ùå Save failed. Try using desktop browser or copy data manually.`);
                console.log('Project data:', data);
            });
        }
        
        function copyProjectData() {
            const data = {
                projectName: state.projectName || 'Untitled',
                rooms: state.rooms,
                savedDate: new Date().toISOString()
            };
            const jsonString = JSON.stringify(data, null, 2);
            
            navigator.clipboard.writeText(jsonString).then(() => {
                showToast(`‚úì Project data copied! Paste into Notes or text file to save.`);
            }).catch((error) => {
                showToast(`‚ùå Copy failed: ${error.message}`);
            });
        }
        
        // AUTO-SAVE to localStorage (works perfectly on iPad!)
        function autoSaveToLocalStorage() {
            try {
                const data = {
                    projectName: state.projectName || 'Untitled',
                    rooms: state.rooms,
                    savedDate: new Date().toISOString()
                };
                localStorage.setItem('cochran_property_autosave', JSON.stringify(data));
                console.log('‚úì Auto-saved to browser storage');
            } catch (error) {
                console.error('Auto-save failed:', error);
            }
        }
        
        // Auto-save disabled - manual save only
        // setInterval(autoSaveToLocalStorage, 30000);
        
        // Also save on any change
        function triggerAutoSave() {
            autoSaveToLocalStorage();
        }
        
        // Load auto-saved data on startup
        function loadAutoSave() {
            try {
                const saved = localStorage.getItem('cochran_property_autosave');
                if (saved) {
                    const data = JSON.parse(saved);
                    const savedDate = new Date(data.savedDate);
                    const minutes = Math.round((Date.now() - savedDate.getTime()) / 60000);
                    
                    if (confirm(`Found auto-saved project "${data.projectName}" from ${minutes} minutes ago. Load it?`)) {
                        state.rooms = data.rooms;
                        state.projectName = data.projectName;
                        updateProjectNameDisplay();
                        updateRoomList();
                        redraw2D();
                        showToast(`‚úì Loaded auto-saved project: ${data.projectName}`);
                    }
                }
            } catch (error) {
                console.error('Load auto-save failed:', error);
            }
        }
        
        function performExport(filename) {
            let report = `COCHRAN CLAIMS - PROPERTY REPORT\n`;
            report += `Property: ${filename}\n`;
            report += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nRooms (${state.rooms.length}):\n\n`;
            state.rooms.forEach((room, i) => {
                let area = 0;
                if (room.floorPoints.length >= 3) {
                    for (let j = 0; j < room.floorPoints.length; j++) {
                        const k = (j + 1) % room.floorPoints.length;
                        area += room.floorPoints[j].x * room.floorPoints[k].y;
                        area -= room.floorPoints[k].x * room.floorPoints[j].y;
                    }
                    area = Math.abs(area / 2) / 900;
                }
                const perim = room.walls.reduce((s, w) => s + parseFloat(w.length), 0);
                
                report += `${i+1}. ${room.name}\n`;
                report += `   Floor Area: ${area.toFixed(1)} sq ft\n`;
                report += `   Perimeter: ${perim.toFixed(1)} ft\n`;
                report += `   Ceiling Height: ${room.ceilingHeight} ft\n`;
                report += `   Wall Area: ${(perim * room.ceilingHeight).toFixed(1)} sq ft\n`;
                
                // Position info
                if (state.rooms.length > 1) {
                    report += `   Position: (${room.positionX || 0}, ${room.positionZ || 0})\n`;
                }
                report += '\n';
                
                // Door details
                if (room.doors.length > 0) {
                    report += `   DOORS (${room.doors.length}):\n`;
                    room.doors.forEach((door, di) => {
                        const wall = room.walls[door.wallIndex];
                        report += `   ${di+1}. ${door.width}" wide on ${wall ? wall.name : 'wall'}\n`;
                        if (door.distanceFromLeft) {
                            report += `      Position: ${door.distanceFromLeft.toFixed(1)} ft from left edge\n`;
                        }
                    });
                    report += '\n';
                }
                
                // Window details
                if (room.windows.length > 0) {
                    report += `   WINDOWS (${room.windows.length}):\n`;
                    room.windows.forEach((win, wi) => {
                        const wall = room.walls[win.wallIndex];
                        report += `   ${wi+1}. ${win.width}" wide on ${wall ? wall.name : 'wall'}\n`;
                        if (win.heightFromFloor) {
                            report += `      Height: ${win.heightFromFloor} ft from floor\n`;
                        }
                        if (win.distanceFromLeft) {
                            report += `      Position: ${win.distanceFromLeft.toFixed(1)} ft from left edge\n`;
                        }
                    });
                    report += '\n';
                }
                
                // Damage markers
                if (room.damageMarkers.length > 0) {
                    report += `   DAMAGE MARKERS: ${room.damageMarkers.length}\n\n`;
                }
                
                report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';
            });
            
            report += `\nReport Generated: ${new Date().toLocaleString()}\n`;
            report += `Generated by: Cochran Claims Property Measurement Tool\n`;
            
            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename} - Report.txt`;
            a.click();
            URL.revokeObjectURL(url);
            showToast(`‚úì Report exported as "${filename} - Report.txt"`);
        }
        
        function performXactimateCSV(filename) {
            // Create CSV header
            let csv = 'Room,FloorArea_SF,Perimeter_LF,CeilingHeight_FT,WallArea_SF,Doors,Windows,DoorDetails,WindowDetails\n';
            
            state.rooms.forEach((room, i) => {
                // Calculate area
                let area = 0;
                if (room.floorPoints.length >= 3) {
                    for (let j = 0; j < room.floorPoints.length; j++) {
                        const k = (j + 1) % room.floorPoints.length;
                        area += room.floorPoints[j].x * room.floorPoints[k].y;
                        area -= room.floorPoints[k].x * room.floorPoints[j].y;
                    }
                    area = Math.abs(area / 2) / 900;
                }
                const perim = room.walls.reduce((s, w) => s + parseFloat(w.length), 0);
                const wallArea = perim * room.ceilingHeight;
                
                // Door details
                let doorDetails = '';
                room.doors.forEach((door, di) => {
                    const wall = room.walls[door.wallIndex];
                    doorDetails += `${door.width}" on ${wall ? wall.name : 'wall'} at ${door.distanceFromLeft ? door.distanceFromLeft.toFixed(1) : '0'}ft; `;
                });
                
                // Window details
                let windowDetails = '';
                room.windows.forEach((win, wi) => {
                    const wall = room.walls[win.wallIndex];
                    windowDetails += `${win.width}" on ${wall ? wall.name : 'wall'} at ${win.distanceFromLeft ? win.distanceFromLeft.toFixed(1) : '0'}ft; `;
                });
                
                // Add row
                csv += `"${room.name}",${area.toFixed(2)},${perim.toFixed(2)},${room.ceilingHeight},${wallArea.toFixed(2)},${room.doors.length},${room.windows.length},"${doorDetails}","${windowDetails}"\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename} - Xactimate.csv`;
            a.click();
            URL.revokeObjectURL(url);
            showToast(`‚úì CSV exported as "${filename} - Xactimate.csv"`);
        }
        
        function performXactimateReport(filename) {
            let report = `XACTIMATE READY REPORT\n`;
            report += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
            report += `PROJECT: ${filename}\n`;
            report += `Date: ${new Date().toLocaleDateString()}\n\n`;
            
            let totalFloorArea = 0;
            let totalWallArea = 0;
            let totalCeilingArea = 0;
            let totalPerimeter = 0;
            let totalDoors = 0;
            let totalWindows = 0;
            
            state.rooms.forEach((room, i) => {
                // Calculate area
                let area = 0;
                if (room.floorPoints.length >= 3) {
                    for (let j = 0; j < room.floorPoints.length; j++) {
                        const k = (j + 1) % room.floorPoints.length;
                        area += room.floorPoints[j].x * room.floorPoints[k].y;
                        area -= room.floorPoints[k].x * room.floorPoints[j].y;
                    }
                    area = Math.abs(area / 2) / 900;
                }
                const perim = room.walls.reduce((s, w) => s + parseFloat(w.length), 0);
                const wallArea = perim * room.ceilingHeight;
                
                totalFloorArea += area;
                totalWallArea += wallArea;
                totalCeilingArea += area;
                totalPerimeter += perim;
                totalDoors += room.doors.length;
                totalWindows += room.windows.length;
                
                report += `\n`;
                report += `ROOM ${i+1}: ${room.name.toUpperCase()}\n`;
                report += `${'‚îÄ'.repeat(50)}\n\n`;
                
                report += `DIMENSIONS:\n`;
                report += `  Floor Area: ${area.toFixed(1)} sq ft\n`;
                report += `  Perimeter: ${perim.toFixed(1)} linear ft\n`;
                report += `  Ceiling Height: ${room.ceilingHeight} ft\n`;
                report += `  Wall Area: ${wallArea.toFixed(1)} sq ft\n\n`;
                
                // Wall breakdown
                report += `WALLS:\n`;
                room.walls.forEach((wall, wi) => {
                    report += `  ${wall.name}: ${wall.length} ft\n`;
                });
                report += `\n`;
                
                // Openings
                if (room.doors.length > 0 || room.windows.length > 0) {
                    report += `OPENINGS:\n`;
                    
                    room.doors.forEach((door, di) => {
                        const wall = room.walls[door.wallIndex];
                        report += `  Door ${di+1}: ${wall ? wall.name : 'Unknown wall'}, ${door.width}" wide`;
                        if (door.distanceFromLeft) {
                            report += `, ${door.distanceFromLeft.toFixed(1)} ft from left`;
                        }
                        report += `\n`;
                    });
                    
                    room.windows.forEach((win, wi) => {
                        const wall = room.walls[win.wallIndex];
                        report += `  Window ${wi+1}: ${wall ? wall.name : 'Unknown wall'}, ${win.width}" wide`;
                        if (win.heightFromFloor) {
                            report += `, ${win.heightFromFloor} ft high`;
                        }
                        if (win.distanceFromLeft) {
                            report += `, ${win.distanceFromLeft.toFixed(1)} ft from left`;
                        }
                        report += `\n`;
                    });
                    report += `\n`;
                }
                
                // Xactimate line items
                report += `XACTIMATE LINE ITEM QUANTITIES:\n`;
                report += `  Paint walls & ceiling: ${(wallArea + area).toFixed(1)} SF\n`;
                report += `  Baseboard: ${perim.toFixed(1)} LF\n`;
                report += `  Crown molding: ${perim.toFixed(1)} LF\n`;
                report += `  Flooring (carpet/tile/hardwood): ${area.toFixed(1)} SF\n`;
                report += `  Drywall (if damaged): ${wallArea.toFixed(1)} SF\n`;
                report += `  Ceiling drywall (if damaged): ${area.toFixed(1)} SF\n`;
                if (room.doors.length > 0) {
                    report += `  Door replacement: ${room.doors.length} EA\n`;
                }
                if (room.windows.length > 0) {
                    report += `  Window replacement: ${room.windows.length} EA\n`;
                }
                report += `\n`;
            });
            
            // Summary section
            report += `\n`;
            report += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
            report += `PROJECT TOTALS\n`;
            report += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
            report += `Total Rooms: ${state.rooms.length}\n`;
            report += `Total Floor Area: ${totalFloorArea.toFixed(1)} SF\n`;
            report += `Total Wall Area: ${totalWallArea.toFixed(1)} SF\n`;
            report += `Total Ceiling Area: ${totalCeilingArea.toFixed(1)} SF\n`;
            report += `Total Perimeter: ${totalPerimeter.toFixed(1)} LF\n`;
            report += `Total Doors: ${totalDoors}\n`;
            report += `Total Windows: ${totalWindows}\n\n`;
            
            report += `AGGREGATE LINE ITEMS FOR XACTIMATE:\n`;
            report += `${'‚îÄ'.repeat(50)}\n`;
            report += `Paint (walls & ceilings): ${(totalWallArea + totalCeilingArea).toFixed(1)} SF\n`;
            report += `Baseboard: ${totalPerimeter.toFixed(1)} LF\n`;
            report += `Crown molding: ${totalPerimeter.toFixed(1)} LF\n`;
            report += `Flooring: ${totalFloorArea.toFixed(1)} SF\n`;
            report += `Drywall walls: ${totalWallArea.toFixed(1)} SF\n`;
            report += `Drywall ceiling: ${totalCeilingArea.toFixed(1)} SF\n`;
            report += `Doors: ${totalDoors} EA\n`;
            report += `Windows: ${totalWindows} EA\n\n`;
            
            report += `\nReport Generated: ${new Date().toLocaleString()}\n`;
            report += `Generated by: Cochran Claims Property Measurement Tool\n`;
            report += `\nREADY FOR XACTIMATE ENTRY\n`;
            
            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename} - Xactimate Ready.txt`;
            a.click();
            URL.revokeObjectURL(url);
            showToast(`‚úì Xactimate report exported as "${filename} - Xactimate Ready.txt"`);
        }
        
        function performExcelExport(filename) {
            // Create a file input to select the template
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.xltm,.xlsx,.xlsm';
            fileInput.style.display = 'none';
            
            fileInput.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                showToast('üìÇ Reading template file...');
                
                try {
                    // Read the template file
                    const arrayBuffer = await file.arrayBuffer();
                    const workbook = XLSX.read(arrayBuffer, { type: 'array', bookVBA: true });
                    
                    // Find ROOM_DIMENSIONS sheet
                    let sheetName = 'ROOM_DIMENSIONS';
                    if (!workbook.SheetNames.includes(sheetName)) {
                        showToast('‚ùå ROOM_DIMENSIONS sheet not found in template!');
                        return;
                    }
                    
                    // Get the existing sheet
                    const ws = workbook.Sheets[sheetName];
                    
                    // Clear existing data rows (keep row 1 headers)
                    // Find the last row with data
                    const range = XLSX.utils.decode_range(ws['!ref']);
                    for (let row = 2; row <= range.e.r; row++) {
                        for (let col = 0; col <= 9; col++) { // Only clear columns A-J (room data)
                            const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                            delete ws[cellAddress];
                        }
                    }
                    
                    // Insert room data starting at row 2
                    let currentRow = 2;
                    
                    state.rooms.forEach((room, i) => {
                        // Calculate floor area from polygon
                        let floorArea = 0;
                        if (room.floorPoints.length >= 3) {
                            for (let j = 0; j < room.floorPoints.length; j++) {
                                const k = (j + 1) % room.floorPoints.length;
                                floorArea += room.floorPoints[j].x * room.floorPoints[k].y;
                                floorArea -= room.floorPoints[k].x * room.floorPoints[j].y;
                            }
                            floorArea = Math.abs(floorArea / 2) / 900; // Convert to sq ft
                        }
                        
                        // Calculate perimeter
                        const perimeter = room.walls.reduce((sum, w) => sum + parseFloat(w.length), 0);
                        
                        // Count missing wall sections
                        let missingWallCount = 0;
                        room.walls.forEach(wall => {
                            if (wall.missingWalls) {
                                missingWallCount += wall.missingWalls.length;
                            }
                        });
                        
                        // Total openings
                        const totalOpenings = room.doors.length + room.windows.length + missingWallCount;
                        
                        // Insert data into columns A-J only (don't touch pricing columns K-N)
                        const rowIndex = currentRow - 1; // Zero-based
                        
                        // Column A: Room Name
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 0 })] = { t: 's', v: room.name };
                        
                        // Column B: Perimeter
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 1 })] = { t: 'n', v: parseFloat(perimeter.toFixed(1)) };
                        
                        // Column C: Height
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 2 })] = { t: 'n', v: room.ceilingHeight };
                        
                        // Column D: Wall SF - COPY FORMULA FROM ROW 2 if it exists, or create new
                        const formulaCell = ws[XLSX.utils.encode_cell({ r: 1, c: 3 })]; // Row 2 (index 1)
                        if (formulaCell && formulaCell.f) {
                            // Copy formula pattern, adjusting row number
                            const newFormula = formulaCell.f.replace(/2/g, currentRow.toString());
                            ws[XLSX.utils.encode_cell({ r: rowIndex, c: 3 })] = { t: 'n', f: newFormula };
                        } else {
                            // Create formula
                            ws[XLSX.utils.encode_cell({ r: rowIndex, c: 3 })] = { t: 'n', f: `B${currentRow}*C${currentRow}` };
                        }
                        
                        // Column E: Floor SF
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 4 })] = { t: 'n', v: parseFloat(floorArea.toFixed(1)) };
                        
                        // Column F: Ceiling SF
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 5 })] = { t: 'n', v: parseFloat(floorArea.toFixed(1)) };
                        
                        // Column G: Door Count
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 6 })] = { t: 'n', v: room.doors.length };
                        
                        // Column H: Window Count
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 7 })] = { t: 'n', v: room.windows.length };
                        
                        // Column I: Missing Wall Sections
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 8 })] = { t: 'n', v: missingWallCount };
                        
                        // Column J: Total Openings
                        ws[XLSX.utils.encode_cell({ r: rowIndex, c: 9 })] = { t: 'n', v: totalOpenings };
                        
                        // Copy pricing formulas from row 2 to this row (columns K-N)
                        for (let col = 10; col <= 13; col++) {
                            const templateCell = ws[XLSX.utils.encode_cell({ r: 1, c: col })];
                            if (templateCell) {
                                const newCell = {};
                                newCell.t = templateCell.t || 'n';
                                
                                if (templateCell.f) {
                                    // Formula exists - copy and adjust row number
                                    newCell.f = templateCell.f.replace(/2/g, currentRow.toString());
                                } else if (templateCell.v !== undefined) {
                                    // Value exists - copy it
                                    newCell.v = templateCell.v;
                                }
                                
                                ws[XLSX.utils.encode_cell({ r: rowIndex, c: col })] = newCell;
                            }
                        }
                        
                        currentRow++;
                    });
                    
                    // Update sheet range
                    const newRange = XLSX.utils.encode_range({
                        s: { r: 0, c: 0 },
                        e: { r: currentRow - 1, c: 13 } // A1 to N(lastRow)
                    });
                    ws['!ref'] = newRange;
                    
                    // Generate output filename - NEW file from template, not modified template
                    const outputFilename = `${filename}.xlsm`;
                    
                    // Write as NEW .xlsm file (preserves macros, doesn't modify template)
                    XLSX.writeFile(workbook, outputFilename, { bookVBA: true });
                    
                    showToast(`‚úì Created ${outputFilename} from template with your data!`);
                    
                } catch (error) {
                    console.error('Error processing template:', error);
                    showToast(`‚ùå Error: ${error.message}`);
                }
            };
            
            // Trigger file selection
            document.body.appendChild(fileInput);
            fileInput.click();
            document.body.removeChild(fileInput);
        }


        function updateProjectNameDisplay() {
            const display = document.getElementById('projectNameDisplay');
            if (display) {
                display.textContent = state.projectName;
            }
        }
        
        function loadProject() {
            showSavedProjectsList();
        }
        
        function showSavedProjectsList() {
            const modal = document.getElementById('savedProjectsModal');
            if (!modal) {
                createSavedProjectsModal();
            }
            
            const savedProjects = JSON.parse(localStorage.getItem('cochran_saved_projects') || '{}');
            const projectNames = Object.keys(savedProjects);
            
            if (projectNames.length === 0) {
                showToast('No saved projects. Use "Load from File" to import .json files.');
                loadFromFile();
                return;
            }
            
            // Build list HTML
            let listHTML = '<div style="max-height: 400px; overflow-y: auto;">';
            projectNames.sort().forEach(name => {
                const project = savedProjects[name];
                const date = new Date(project.savedDate);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                const roomCount = project.rooms.length;
                
                listHTML += `
                    <div style="border: 1px solid #ddd; padding: 15px; margin-bottom: 10px; border-radius: 8px; background: #f9f9f9;">
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div style="flex: 1;">
                                <div style="font-weight: bold; font-size: 16px; margin-bottom: 5px;">${name}</div>
                                <div style="font-size: 12px; color: #666;">
                                    ${roomCount} room${roomCount !== 1 ? 's' : ''} ‚Ä¢ Saved ${dateStr}
                                </div>
                            </div>
                            <div style="display: flex; gap: 5px;">
                                <button onclick="loadSavedProject('${name}')" style="padding: 8px 15px; background: #4A90E2; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">
                                    Load
                                </button>
                                <button onclick="deleteSavedProject('${name}')" style="padding: 8px 15px; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">
                                    Delete
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });
            listHTML += '</div>';
            
            listHTML += `
                <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #ddd;">
                    <button onclick="loadFromFile()" style="width: 100%; padding: 12px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold;">
                        üìÇ Load from File (.json)
                    </button>
                </div>
            `;
            
            document.getElementById('savedProjectsList').innerHTML = listHTML;
            document.getElementById('savedProjectsModal').style.display = 'flex';
        }
        
        function createSavedProjectsModal() {
            const modal = document.createElement('div');
            modal.id = 'savedProjectsModal';
            modal.style.cssText = 'display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;';
            
            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 12px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto;">
                    <h2 style="margin: 0 0 20px 0; color: #1e3c72;">üìÇ Load Project</h2>
                    <div id="savedProjectsList"></div>
                    <button onclick="closeSavedProjectsModal()" style="margin-top: 20px; padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; width: 100%;">
                        Cancel
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function closeSavedProjectsModal() {
            document.getElementById('savedProjectsModal').style.display = 'none';
        }
        
        function loadSavedProject(name) {
            const savedProjects = JSON.parse(localStorage.getItem('cochran_saved_projects') || '{}');
            const project = savedProjects[name];
            
            if (project) {
                state.rooms = project.rooms || [];
                state.projectName = project.projectName || name;
                state.currentRoomIndex = 0;
                updateRoomList();
                updateProjectNameDisplay();
                redraw2D();
                updateStats();
                closeSavedProjectsModal();
                showToast(`‚úì Loaded "${name}"`);
            } else {
                showToast(`‚ùå Project "${name}" not found`);
            }
        }
        
        function deleteSavedProject(name) {
            if (confirm(`Delete "${name}"? This cannot be undone.`)) {
                const savedProjects = JSON.parse(localStorage.getItem('cochran_saved_projects') || '{}');
                delete savedProjects[name];
                localStorage.setItem('cochran_saved_projects', JSON.stringify(savedProjects));
                showToast(`‚úì Deleted "${name}"`);
                showSavedProjectsList(); // Refresh list
            }
        }
        
        function loadFromFile() {
            closeSavedProjectsModal();
            document.getElementById('fileInput').click();
        }

        function loadProject() {
            showSavedProjectsList();
        }

        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const data = JSON.parse(ev.target.result);
                        state.rooms = data.rooms || [];
                        state.projectName = data.projectName || 'Untitled Project';
                        state.currentRoomIndex = 0;
                        updateRoomList();
                        updateProjectNameDisplay();
                        redraw2D();
                        updateStats();
                        showToast(`‚úì Loaded "${state.projectName}"`);
                    } catch (err) {
                        showToast('‚ùå Error loading');
                    }
                };
                reader.readAsText(file);
            }
        });

        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('active');
            setTimeout(() => toast.classList.remove('active'), 3000);
        }

        function updateModeIndicator() {
            const indicator = document.getElementById('modeIndicator');
            const clearBtn = document.getElementById('clearModeBtn');
            
            if (state.wallSelectionMode) {
                indicator.textContent = 'WALL SELECTION MODE - Click on a wall';
                indicator.className = 'mode-indicator wall-mode';
                clearBtn.style.display = 'block';
            } else if (state.currentFeature) {
                indicator.textContent = `PLACING ${state.currentFeature.toUpperCase()}`;
                indicator.className = 'mode-indicator wall-mode';
                clearBtn.style.display = 'block';
            } else {
                indicator.textContent = 'üìè EDIT MODE - Click feature to edit/delete';
                indicator.className = 'mode-indicator delete-mode';
                clearBtn.style.display = 'none';
            }
        }

        function clearAllModes() {
            console.log('*** CLEARING ALL MODES ***');
            state.wallSelectionMode = false;
            state.currentFeature = null;
            state.selectedWall = null;
            state.hoveredWall = null;
            state.clickPoint = null;
            
            document.querySelectorAll('.feature-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('instructionBanner').classList.remove('active');
            
            updateModeIndicator();
            redraw2D();
            showToast('‚úì Modes cleared - Click to reposition features');
        }
    
        // --- Ensure UI onclick handlers can find functions (prevents "nothing happens" failures) ---
        // Some browsers isolate function declarations depending on how the file is served.
        // Explicitly attach the key UI actions to window.
        try {
            window.addNewRoom = addNewRoom;
            window.loadProject = loadProject;
            window.saveProject = saveProject;
            window.switchTo2D = switchTo2D;
            window.switchTo3D = switchTo3D;
            window.resetView = resetView;
            window.undo = undo;
            window.showMissingWallModal = showMissingWallModal;
            window.confirmMissingWall = confirmMissingWall;
            window.cancelMissingWall = cancelMissingWall;
            window.deleteCurrentMissingWall = deleteCurrentMissingWall;
            window.loadSavedProject = loadSavedProject;
            window.deleteSavedProject = deleteSavedProject;
            window.closeSavedProjectsModal = closeSavedProjectsModal;
            window.loadFromFile = loadFromFile;
            window.setDoorHinge = setDoorHinge;
            window.setDoorSwingDirection = setDoorSwingDirection;
            window.selectTurn = selectTurn;
            window.previewFloorPlan = previewFloorPlan;
            window.livePreview = livePreview;
        } catch (e) {
            console.warn('Window export failed:', e);
        }
        
        // Register Service Worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                    .then(registration => {
                        console.log('‚úì Service Worker registered:', registration.scope);
                    })
                    .catch(error => {
                        console.log('Service Worker registration failed:', error);
                    });
            });
        }
</script>

<!-- iPad/iOS Compatibility Script -->
<script>
// ========== IPAD/IOS TOUCH FIX ==========
// Makes ALL buttons work reliably on iPad/iPhone
(function() {
    'use strict';
    
    console.log('üéØ Loading iPad compatibility fixes...');
    
    // Wait for DOM to be fully loaded
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initIPadFixes);
    } else {
        initIPadFixes();
    }
    
    function initIPadFixes() {
        console.log('üì± Initializing iPad button fixes...');
        
        // Fix ALL buttons for touch
        const buttons = document.querySelectorAll('button');
        console.log(`Found ${buttons.length} buttons to fix`);
        
        buttons.forEach((btn, index) => {
            // Add touch-friendly CSS
            btn.style.webkitTapHighlightColor = 'rgba(0,0,0,0.1)';
            btn.style.touchAction = 'manipulation';
            btn.style.userSelect = 'none';
            
            // Add active state visual feedback
            btn.addEventListener('touchstart', function() {
                this.style.opacity = '0.7';
            }, { passive: true });
            
            btn.addEventListener('touchend', function() {
                this.style.opacity = '1';
            }, { passive: true });
            
            btn.addEventListener('touchcancel', function() {
                this.style.opacity = '1';
            }, { passive: true });
        });
        
        console.log('‚úÖ All buttons fixed for iPad/iOS!');
        console.log('‚úÖ Tap any button - it should work now!');
    }
    
    // Also fix on window load as backup
    window.addEventListener('load', function() {
        console.log('‚úÖ Page fully loaded - buttons ready!');
    });
})();
</script>

</body>
</html>